// Generated by dts-bundle-generator v9.5.1

// Generated by dts-bundle-generator v9.5.1
export interface SchemaTypeBase<N extends "string" | "number" | "boolean" | "array" | "enum", R extends boolean = false, V extends readonly (string | number)[] | never = never> {
	/**
	 * **Тип поля контекста**
	 */
	type: N;
	/**
	 * **Является ли поле обязательным**
	 *
	 * @remarks Присутствует в схеме только для обязательных полей
	 */
	required?: R;
	/**
	 * **Название поля (для отображения в UI)**
	 */
	label?: string;
	/**
	 * **Значения для enum**
	 *
	 * Используется только для `enum` контекстного типа
	 *
	 * Значения могут отсутствовать для enum ({@link Types.enum | декларация})
	 * {@includeCode ./test/enum.spec.ts#emptySchema}
	 */
	values?: V;
	/**
	 * **Флаг идентификатора** (только для примитивов и enum которые являются обязательными)
	 *
	 * @remarks Позволяет пометить поле как идентификатор (id)
	 */
	id?: true;
	/**
	 * **Имя таблицы данных** (только для array)
	 */
	data?: string;
}
export type SchemaType<N extends "string" | "number" | "boolean" | "array" | "enum", R extends boolean = false, D extends unknown = undefined, V extends readonly (string | number)[] | never = never> = [
	D
] extends [
	undefined
] ? SchemaTypeBase<N, R, V> & {
	default?: D;
} : SchemaTypeBase<N, R, V> & {
	default: D;
};
/**
 * # Схема контекста
 *
 * Используется в системе для **хранения** и **передачи** структуры контекста.
 *
 * Формируется в процессе инициализации контекста при помощи {@link Types | деклараций типов}.
 *
 * Описывает {@link SchemaType.type | простые типы} значений контекста.
 * - строка
 * - число
 * - логическое значение
 * - однородный массив примитивов (числа, строки, логические значения)
 * - однородное перечисление (строки, числа)
 *
 * Содержит:
 * - {@link SchemaType.type | имя типа}
 * - {@link SchemaType.required | является ли поле обязательным}
 * - {@link SchemaType.default | значение по умолчанию}
 * - {@link SchemaType.values | значения перечисления}
 *
 * А так же метаданные полей контекста (для отображения в UI):
 * - {@link SchemaType.label | название }
 * - {@link ToDo.description | описание }
 *
 * Структура схемы стремиться быть минимальной для сокращения объёма данных.
 * Минимизация данных позволяет оптимизировать память и скорость работы с данными.
 * - скорость обработки при сериализации и десериализации
 * - объем памяти
 * - объем хранения
 * - сетевой трафик
 */
export type Schema = Record<string, SchemaType<"string", true | false, undefined> | SchemaType<"string", true | false, string> | SchemaType<"boolean", true | false, undefined> | SchemaType<"boolean", true | false, boolean> | SchemaType<"number", true | false, undefined> | SchemaType<"number", true | false, number> | SchemaType<"array", true | false, undefined> | SchemaType<"array", true | false, (string | number | boolean)[]> | SchemaType<"enum", true | false, undefined, readonly (string | number)[]> | SchemaType<"enum", true | false, string | number, readonly (string | number)[]>>;
/**
 * @readonly
 * Значения контекста
 *
 * @remarks содержит только актуальные значения каждого поля
 */
export type Values<C extends Schema> = {
	[K in keyof C]: ExtractValue<C[K]>;
};
/**
 * Обновляет значения в контексте
 *
 * Обновляет только существующие ключи. Игнорирует undefined.
 * {@includeCode ./test/update.spec.ts#undefined}
 *
 * Для optional полей поддерживается установка null
 * {@includeCode ./test/update.spec.ts#optionalNull}
 *
 * @throws {TypeError} `[Context.update] "{field}": поле не может быть null` - при попытке установить null для required поля
 * {@includeCode ./test/update.spec.ts#requiredNull}
 *
 * @throws {TypeError} `[Context.update] "{field}": ожидается плоский массив примитивов` - при попытке установить nested массив или массив с объектами
 * {@includeCode ./test/update.spec.ts#arrayErrors}
 *
 * @throws {TypeError} `[Context.update] "{field}": объекты и функции запрещены` - при попытке установить объект или функцию в примитивное поле
 * {@includeCode ./test/update.spec.ts#primitiveErrors}
 *
 * @throws {TypeError} `[Context.update] "{field}": должно быть '{values}', получено '{value}'` - при попытке установить недопустимое значение для enum поля
 * {@includeCode ./test/update.spec.ts#enumErrors}
 *
 * @param values - Значения для обновления
 * @returns Значения, которые были обновлены
 */
export type Update<C extends Schema> = (values: Partial<Values<C>>) => Partial<Values<C>>;
export type ExtractValue<E> = E extends SchemaType<infer N, infer R, infer D, infer V> ? N extends "enum" ? R extends true ? V extends readonly (string | number)[] ? V[number] : D : (V extends readonly (string | number)[] ? V[number] : D) | null : N extends "array" ? R extends true ? D : D | null : N extends "string" ? R extends true ? string : string | null : N extends "number" ? R extends true ? number : number | null : N extends "boolean" ? R extends true ? boolean : boolean | null : never : never;
/**
 * # Типы для описания контекста.
 *
 * Является фабрикой для создания {@link Schema | схемы контекста}.
 * Каждый тип предоставляет методы `.optional()` и `.required()` с унифицированным API.
 *
 * @example Базовое использование
 * ```ts
 * const schema = contextSchema((types) => ({
 *   name: types.string.required("Иван", { label: "Имя" }),
 *   age: types.number.optional({ label: "Возраст" }),
 *   tags: types.array.optional({ label: "Теги", data: "user_tags" }),
 *   role: types.enum("user", "admin").required("user", { id: true })
 * }))
 * ```
 *
 * ## Метаданные полей
 *
 * - `label?: string` — заголовок поля для UI
 * - `id?: true` — только для обязательных примитивов и enum (отметка идентификатора)
 * - `data?: string` — только для array (имя таблицы/источника данных)
 *
 * ## Правила типизации
 *
 * - **Опциональные** поля могут принимать `null` и имеют опциональный default
 * - **Обязательные** поля всегда должны иметь значение по умолчанию
 * - Все параметры передаются в одном вызове: `method(default?, options?)`
 */
export type Types = {
	/**
	 * Строковый тип. Поддерживает значения по умолчанию и метаданные label, id.
	 *
	 * @example
	 * ```ts
	 * types.string.required("default", { label: "Имя", id: true })
	 * types.string.optional({ label: "Описание" })
	 * types.string.optional("default")
	 * ```
	 */
	string: TypePrimitive<string, "string">;
	/**
	 * Числовой тип. Поддерживает значения по умолчанию и метаданные label, id.
	 *
	 * @example
	 * ```ts
	 * types.number.required(0, { label: "Возраст", id: true })
	 * types.number.optional({ label: "Счетчик" })
	 * types.number.optional(100)
	 * ```
	 */
	number: TypePrimitive<number, "number">;
	/**
	 * Логический тип. Поддерживает значения по умолчанию и метаданные label, id.
	 *
	 * @example
	 * ```ts
	 * types.boolean.required(false, { label: "Активен" })
	 * types.boolean.optional({ label: "Флаг" })
	 * types.boolean.optional(true)
	 * ```
	 */
	boolean: TypePrimitive<boolean, "boolean">;
	/**
	 * Массив примитивов. Плоский и однородный. Поддерживает метаданные label, data.
	 *
	 * @example
	 * ```ts
	 * types.array.required<string>([], { label: "Теги", data: "tags" })
	 * types.array.optional<number>({ label: "Значения" })
	 * types.array.optional([1, 2, 3])
	 * ```
	 */
	array: TypeArray;
	/**
	 * Перечисления. Однородные значения строк или чисел. Значения могут отсутствовать.
	 *
	 * @example
	 * ```ts
	 * types.enum("user", "admin").required("user", { label: "Роль", id: true })
	 * types.enum(1, 2, 3).optional({ label: "Приоритет" })
	 * types.enum().optional() // без значений
	 * ```
	 */
	enum: TypeEnum;
};
export interface TypePrimitive<T extends string | number | boolean, N extends "string" | "number" | "boolean"> {
	optional(options?: {
		label?: string;
	}): SchemaType<N, false>;
	optional<D extends T>(defaultValue?: D, options?: {
		label?: string;
	}): SchemaType<N, false, D>;
	required: <D extends T>(defaultValue: D, options?: {
		label?: string;
		id?: true;
	}) => SchemaType<N, true, D>;
}
export type TypeArray = {
	optional: {
		(options?: {
			label?: string;
			data?: string;
		}): SchemaType<"array", false>;
		<D extends (string | number | boolean)[]>(defaultValue?: D, options?: {
			label?: string;
			data?: string;
		}): SchemaType<"array", false, D>;
	};
	required: <D extends string | number | boolean>(defaultValue: D[], options?: {
		label?: string;
		data?: string;
	}) => SchemaType<"array", true, D[]>;
};
export type TypeEnum = <const V extends readonly (string | number)[]>(...values: V) => {
	optional(options?: {
		label?: string;
	}): SchemaType<"enum", false, undefined, V>;
	optional<D extends V[number] | undefined>(defaultValue?: D, options?: {
		label?: string;
	}): SchemaType<"enum", false, D, V>;
	required: <D extends V[number]>(defaultValue: D, options?: {
		label?: string;
		id?: true;
	}) => SchemaType<"enum", true, D, V>;
};
/**
 * Chain API для создания процесса с опциональными параметрами label и desc.
 * Позволяет удобно и строго типизировано описывать обработчики процессов автомата.
 *
 * @template C - схема контекста автомата
 * @template Res - возвращаемый тип результата action
 *
 * @example
 * ```typescript
 * const chain = process({
 *   label: "my_process",
 *   desc: "Описание процесса"
 * })
 *   .action(({ context }) => ({ name: context.name }))
 *   .success(({ update, data }) => update({ name: data.name }))
 *   .error(({ update, error }) => update({ name: error.message }))
 *
 * chain.getResult() // { action, success, error, label?, desc? }
 * ```
 */
export type ProcessChain<C extends Schema, I extends Core> = {
	/**
	 * Добавляет основную функцию процесса.
	 *
	 * Функция может быть как синхронной, так и асинхронной.
	 * При выбросе исключения вызывается обработчик error.
	 * При успешном выполнении вызывается обработчик success.
	 *
	 * @param fn - функция процесса, вызываемая автоматом
	 * @returns цепочку для дальнейшего конфигурирования
	 *
	 * @example
	 * ```typescript
	 * // Синхронная функция
	 * .action(({ context }) => {
	 *   if (!context.email) {
	 *     throw new Error('Email обязателен')
	 *   }
	 *   return { isValid: true }
	 * })
	 *
	 * // Асинхронная функция
	 * .action(async ({ context }) => {
	 *   const response = await fetch('/api/data', {
	 *     method: 'POST',
	 *     body: JSON.stringify(context)
	 *   })
	 *   return await response.json()
	 * })
	 *
	 * // Предпочтительный формат action с Promise
	 * .action(({ core }) => new Promise((resolve, reject) => {
	 *   // асинхронная логика
	 *   resolve({ success: true })
	 * }))
	 * ```
	 */
	action: <Res>(fn: (params: ActionParams<C, I>) => Res | Promise<Res>) => ActionChain<C, I, Res>;
};
/**
 * Параметры для action
 * @template C - схема контекста автомата
 * @template I - тип ядра автомата
 */
export type ActionParams<C extends Schema, I extends Core> = {
	/** Контекст */
	context: Values<C>;
	/** Ядро */
	core: I;
	/** Схема контекста */
	schema: C;
	/** Полный идентификатор актора с методом destroy */
	self: Self;
};
/**
 * Цепочка для декларации action с типобезопасной поддержкой success и error.
 * Позволяет удобно и строго типизировано описывать обработчики процессов автомата.
 *
 * @template C - схема контекста автомата
 * @template Res - возвращаемый тип результата action
 *
 * @example
 * ```typescript
 * const chain = action(({ context, core, schema, self }) => {
 *   // Доступ ко всем параметрам процесса
 *   // self.destroy() доступен в процессах
 *   return { name: context.name }
 * })
 *   .success(({ update, data }) => update({ name: data.name }))
 *   .error(({ update, error }) => update({ name: error.message }))
 *
 * chain.getResult() // { action, success, error }
 * ```
 */
export type ActionChain<C extends Schema, I extends Core, Res> = {
	/**
	 * Основная функция процесса, вызывается автоматом.
	 *
	 * Получает полный набор параметров для выполнения процесса и должна вернуть результат или выбросить исключение.
	 *
	 * @param params - объект с параметрами процесса:
	 *   - `context` - текущий контекст актора
	 *   - `core` - ядро актора для сложных данных
	 *   - `schema` - схема контекста для валидации и установки значений по умолчанию
	 *   - `self` - полный идентификатор актора с методом destroy
	 * @returns результат процесса (может быть промисом)
	 *
	 * @example
	 * ```typescript
	 * action: ({ context, core, schema, self }) => {
	 *   // Доступ к контексту
	 *   console.log(context.email, context.password)
	 *
	 *   // Доступ к ядру
	 *   core.users.push({ name: context.name })
	 *
	 *   // Доступ к схеме для валидации
	 *   const isValid = schema.email.validate(context.email)
	 *
	 *   // self.destroy() доступен для уничтожения актора
	 *   // self.meta, self.actor, self.path доступны
	 *
	 *   // Возврат результата
	 *   return { userId: 123, token: "abc" }
	 * }
	 * ```
	 */
	action: (params: ActionParams<C, I>) => Res | Promise<Res>;
	/**
	 * Добавляет обработчик успешного завершения процесса.
	 *
	 * Вызывается когда action завершился успешно (не выбросил исключение).
	 * Получает функцию update для изменения контекста и данные от action.
	 *
	 * **ВАЖНО: success обработчик должен быть синхронным.**
	 * Асинхронные операции выполняйте только в action функциях.
	 * Для последовательных асинхронных операций создавайте отдельные процессы.
	 *
	 * @param handler - функция, вызываемая при успехе (получает update и data)
	 * @returns цепочку для дальнейшего конфигурирования
	 *
	 * @example
	 * ```typescript
	 * // Предпочтительный формат success/error
	 * .success(({ update, data }) => update({ status: data.status }))
	 * .error(({ update, error }) => update({ status: "error", error: error.message }))
	 *
	 * // Расширенный формат
	 * .success(({ update, data }) => {
	 *   // Обновляем контекст данными от action
	 *   update({
	 *     userId: data.userId,
	 *     token: data.token,
	 *     isAuthenticated: true,
	 *     error: ""
	 *   })
	 * })
	 * ```
	 */
	success: (handler: (params: {
		update: Update<C>;
		data: Res;
	}) => void) => ActionChain<C, I, Res>;
	/**
	 * Добавляет обработчик ошибки выполнения процесса.
	 *
	 * Вызывается когда action выбросил исключение.
	 * Получает функцию update для изменения контекста и объект ошибки.
	 *
	 * **ВАЖНО: error обработчик должен быть синхронным.**
	 * Асинхронные операции выполняйте только в action функциях.
	 * Для последовательных асинхронных операций создавайте отдельные процессы.
	 *
	 * @param handler - функция, вызываемая при ошибке (получает update и error типа Error)
	 * @returns цепочку для дальнейшего конфигурирования
	 *
	 * @example
	 * ```typescript
	 * // Предпочтительный формат success/error
	 * .success(({ update, data }) => update({ status: data.status }))
	 * .error(({ update, error }) => update({ status: "error", error: error.message }))
	 *
	 * // Расширенный формат
	 * .error(({ update, error }) => {
	 *   // Обрабатываем ошибку
	 *   update({
	 *     error: error.message,
	 *     isAuthenticated: false,
	 *     isLoading: false
	 *   })
	 * })
	 * ```
	 */
	error: (handler: (params: {
		update: Update<C>;
		error: Error;
	}) => void) => ActionChain<C, I, Res>;
	/**
	 * Возвращает итоговый объект конфигурации процесса для автомата.
	 *
	 * Содержит все обработчики и метаданные процесса.
	 *
	 * @returns объект с action, success, error, label и desc (если заданы)
	 *
	 * @example
	 * ```typescript
	 * const processConfig = chain.getResult()
	 * // {
	 * //   action: Function,
	 * //   success: Function,
	 * //   error: Function,
	 * //   label: "Авторизация",
	 * //   desc: "Процесс входа пользователя"
	 * // }
	 * ```
	 */
	getResult: () => Process<C, I, Res>;
};
/**
 * Конфигурация одного процесса
 *
 * Содержит основную функцию action и опциональные обработчики success/error.
 * Также может содержать метаданные label и desc.
 *
 * @template C - схема контекста автомата
 * @template Res - возвращаемый тип результата action
 *
 * @example
 * ```typescript
 * const process: Process<MyContext, { userId: number }> = {
 *   label: "Авторизация",
 *   desc: "Процесс входа пользователя",
 *   action: async ({ context, core, schema, self }) => {
 *     // Логика авторизации с доступом ко всем параметрам
 *     // self.destroy() доступен для уничтожения актора
 *     return { userId: 123 }
 *   },
 *   success: ({ update, data }) => {
 *     update({ userId: data.userId, isAuthenticated: true })
 *   },
 *   error: ({ update, error }) => {
 *     update({ error: error.message })
 *   }
 * }
 * ```
 */
export type Process<C extends Schema = Schema, I extends Core = Core, Res = any> = {
	/** Основная функция процесса */
	action: (params: ActionParams<C, I>) => Res | Promise<Res>;
	/** Обработчик успешного завершения */
	success?: (params: {
		update: Update<C>;
		data: Res;
	}) => void;
	/** Обработчик ошибки */
	error?: (params: {
		update: Update<C>;
		error: Error;
	}) => void;
	/** Название процесса для документации */
	label?: string;
	/** Описание процесса для документации */
	desc?: string;
};
/**
 * Обработчик действия процесса.
 * Содержит функцию и список полей контекста, которые читаются.
 */
export type ParsedActionHandler = {
	/** Список полей контекста, которые читаются в обработчике */
	read?: string[];
	/** Строковое представление функции action для десериализации */
	src: string;
};
/**
 * Обработчик успеха или ошибки процесса.
 * Содержит функцию, список полей для чтения и записи.
 */
export type ParsedHandler = {
	/** Список полей контекста, которые читаются в обработчике */
	read?: string[];
	/** Список полей контекста, которые записываются в обработчике */
	write?: string[];
	/** Строковое представление функции для десериализации */
	src: string;
};
/**
 * Распарсенный процесс с обработчиками.
 * Содержит обработчики для действия, успеха и ошибки.
 */
export type ParsedProcess = {
	/** Название процесса */
	label?: string;
	/** Описание процесса */
	desc?: string;
	/** Обработчик основного действия процесса */
	action: ParsedActionHandler;
	/** Обработчик успешного завершения процесса */
	success?: ParsedHandler;
	/** Обработчик ошибки процесса */
	error?: ParsedHandler;
};
/**
 * Схема процессов
 * Объект с распарсенными процессами
 */
export type ProcessesSchema = Record<string, ParsedProcess>;
/**
 * Тип билдера для декларации набора процессов автомата.
 *
 * Позволяет создавать типизированные процессы с удобным API.
 *
 * @template C - схема контекста автомата
 * @template S - строковые ключи состояний/процессов
 * @param process - фабрика для создания цепочки ProcessChain
 * @returns объект, где ключи — имена процессов, а значения — цепочки ActionChain
 *
 * @includeExample ./proc/test/actions.basic.spec.ts
 * @includeExample ./proc/test/actions.types.spec.ts
 */
export type ProcessesDeclaration<C extends Schema = Schema, S extends string = string, I extends Core = Core> = (process: (config?: ProcessConfig) => ProcessChain<C, I>) => Partial<Record<S, ActionChain<C, I, any>>>;
export type ProcessConfig = {
	/** Название*/
	label?: string;
	/** Описание */
	desc?: string;
};
/**
 * # Условия для булевых значений (required)
  
   Позволяет определять условия для обязательных булевых значений в контексте.
   Не поддерживает проверку на null, так как required поля всегда имеют значение.
  
   ## Параметры:
   | Параметр   | Тип     | Описание                           |
   | ---------- | ------- | ---------------------------------- |
   | eq         | boolean | Равно указанному булеву значению   |
   | notEq      | boolean | Не равно указанному булеву значению|
   | logicalEq  | boolean | Логическое равенство               |
   
   @includeExample ./state/test/conditions.boolean.spec.ts
   */
export type CondBooleanRequired = boolean | {
	/** Равно указанному булеву значению */
	eq?: boolean;
	/** Не равно указанному булеву значению */
	notEq?: boolean;
	/** Логическое равенство */
	logicalEq?: boolean;
};
/**
 * # Условия для булевых значений (optional)
  
   Позволяет определять условия для опциональных булевых значений в контексте.
   Поддерживает проверку на null.
  
   ## Параметры:
   | Параметр   | Тип     | Описание                           |
   | ---------- | ------- | ---------------------------------- |
   | null       | boolean | Является ли значение null          |
   | eq         | boolean | Равно указанному булеву значению   |
   | notEq      | boolean | Не равно указанному булеву значению|
   | logicalEq  | boolean | Логическое равенство               |
   
   @example
   ```typescript
   // Простое условие
   isActive: true
   
   // Проверка на null
   isVerified: null
   
   // Сложное условие
   isAdmin: { eq: true }
   isVerified: { null: true }
   ```
   */
export type CondBooleanOptional = boolean | null | {
	/** Является ли значение null */
	null?: boolean;
	/** Равно указанному булеву значению */
	eq?: boolean;
	/** Не равно указанному булеву значению */
	notEq?: boolean;
	/** Логическое равенство */
	logicalEq?: boolean;
};
/**
 * # Условия для строковых значений (required)
  
   Позволяет определять условия для обязательных строковых значений в контексте.
   Не поддерживает проверку на null, так как required поля всегда имеют значение.
  
   ## Параметры:
   | Параметр      | Тип     | Описание                           |
   | ------------- | ------- | ---------------------------------- |
   | startsWith    | string  | Начинается ли с указанной строки   |
   | endsWith      | string  | Заканчивается ли на указанную строку|
   | include       | string  | Включает ли указанную подстроку    |
   | pattern       | RegExp  | Шаблон регулярного выражения      |
   | eq            | string  | Равно указанной строке             |
   | notEq         | string  | Не равно указанной строке          |
   | notInclude    | string  | Не включает указанную подстроку    |
   | notStartsWith | string  | Не начинается с указанной строки   |
   | notEndsWith   | string  | Не заканчивается на указанную строку|
   | length        | number \| { min?: number; max?: number } | Длина строки |
   | between       | [string, string] | Должно быть между двумя строками |
   
   @includeExample ./state/test/conditions.string.spec.ts
   */
export type CondStringRequired = string | RegExp | {
	/** Начинается ли с указанной строки */
	startsWith?: string;
	/** Заканчивается ли на указанную строку */
	endsWith?: string;
	/** Включает ли указанную подстроку */
	include?: string;
	/** Шаблон регулярного выражения */
	pattern?: RegExp;
	/** Равно указанной строке */
	eq?: string;
	/** Не равно указанной строке */
	notEq?: string;
	/** Не включает указанную подстроку */
	notInclude?: string;
	/** Не начинается с указанной строки */
	notStartsWith?: string;
	/** Не заканчивается на указанную строку */
	notEndsWith?: string;
	/** Длина строки */
	length?: number | {
		min?: number;
		max?: number;
	};
	/** Должно быть между двумя строками */
	between?: [
		string,
		string
	];
};
/**
 * # Условия для строковых значений (optional)
  
   Позволяет определять условия для опциональных строковых значений в контексте.
   Поддерживает проверку на null.
  
   ## Параметры:
   | Параметр      | Тип     | Описание                           |
   | ------------- | ------- | ---------------------------------- |
   | null          | boolean | Является ли значение null          |
   | startsWith    | string  | Начинается ли с указанной строки   |
   | endsWith      | string  | Заканчивается ли на указанную строку|
   | include       | string  | Включает ли указанную подстроку    |
   | pattern       | RegExp  | Шаблон регулярного выражения      |
   | eq            | string  | Равно указанной строке             |
   | notEq         | string  | Не равно указанной строке          |
   | notInclude    | string  | Не включает указанную подстроку    |
   | notStartsWith | string  | Не начинается с указанной строки   |
   | notEndsWith   | string  | Не заканчивается на указанную строку|
   | length        | number \| { min?: number; max?: number } | Длина строки |
   | between       | [string, string] | Должно быть между двумя строками |
   
   @example
   ```typescript
   // Простое условие
   name: 'John'
   
   // Проверка на null
   name: null
   
   // Регулярное выражение
   email: /@/
   
   // Сложное условие
   name: { length: { min: 2 } }
   email: { pattern: /@/, include: '.com' }
   ```
   */
export type CondStringOptional = string | RegExp | null | {
	/** Является ли значение null */
	null?: boolean;
	/** Начинается ли с указанной строки */
	startsWith?: string;
	/** Заканчивается ли на указанную строку */
	endsWith?: string;
	/** Включает ли указанную подстроку */
	include?: string;
	/** Шаблон регулярного выражения */
	pattern?: RegExp;
	/** Равно указанной строке */
	eq?: string;
	/** Не равно указанной строке */
	notEq?: string;
	/** Не включает указанную подстроку */
	notInclude?: string;
	/** Не начинается с указанной строки */
	notStartsWith?: string;
	/** Не заканчивается на указанную строку */
	notEndsWith?: string;
	/** Длина строки */
	length?: number | {
		min?: number;
		max?: number;
	};
	/** Должно быть между двумя строками */
	between?: [
		string,
		string
	];
};
/**
 * # Условия для числовых значений (required)
  
   Позволяет определять условия для обязательных числовых значений в контексте.
   Не поддерживает проверку на null, так как required поля всегда имеют значение.
  
   ## Параметры:
   | Параметр   | Тип     | Описание                           |
   | ---------- | ------- | ---------------------------------- |
   | eq         | number  | Равно указанному числу             |
   | gt         | number  | Больше указанного числа            |
   | gte        | number  | Больше или равно указанному числу  |
   | lt         | number  | Меньше указанного числа            |
   | lte        | number  | Меньше или равно указанному числу  |
   | notEq      | number  | Не равно указанному числу          |
   | notGt      | number  | Не больше указанного числа         |
   | notGte     | number  | Не больше или равно указанному числу|
   | notLt      | number  | Не меньше указанного числа         |
   | notLte     | number  | Не меньше или равно указанному числу|
   | between    | [number, number] | Должно быть между двумя числами |
   
   @includeExample ./state/test/conditions.number.spec.ts
   */
export type CondNumberRequired = number | {
	/** Равно указанному числу */
	eq?: number;
	/** Больше указанного числа */
	gt?: number;
	/** Больше или равно указанному числу */
	gte?: number;
	/** Меньше указанного числа */
	lt?: number;
	/** Меньше или равно указанному числу */
	lte?: number;
	/** Не равно указанному числу */
	notEq?: number;
	/** Не больше указанного числа */
	notGt?: number;
	/** Не больше или равно указанному числу */
	notGte?: number;
	/** Не меньше указанного числа */
	notLt?: number;
	/** Не меньше или равно указанному числу */
	notLte?: number;
	/** Должно быть между двумя числами */
	between?: [
		number,
		number
	];
};
/**
 * # Условия для числовых значений (optional)
  
   Позволяет определять условия для опциональных числовых значений в контексте.
   Поддерживает проверку на null.
  
   ## Параметры:
   | Параметр   | Тип     | Описание                           |
   | ---------- | ------- | ---------------------------------- |
   | null       | boolean | Является ли значение null          |
   | eq         | number  | Равно указанному числу             |
   | gt         | number  | Больше указанного числа            |
   | gte        | number  | Больше или равно указанному числу  |
   | lt         | number  | Меньше указанного числа            |
   | lte        | number  | Меньше или равно указанному числу  |
   | notEq      | number  | Не равно указанному числу          |
   | notGt      | number  | Не больше указанного числа         |
   | notGte     | number  | Не больше или равно указанному числу|
   | notLt      | number  | Не меньше указанного числа         |
   | notLte     | number  | Не меньше или равно указанному числу|
   | between    | [number, number] | Должно быть между двумя числами |
   
   @example
   ```typescript
   // Простое условие
   age: 18
   
   // Проверка на null
   age: null
   
   // Сложное условие
   age: { gte: 18, lte: 65 }
   score: { between: [0, 100] }
   ```
   */
export type CondNumberOptional = number | null | {
	/** Является ли значение null */
	null?: boolean;
	/** Равно указанному числу */
	eq?: number;
	/** Больше указанного числа */
	gt?: number;
	/** Больше или равно указанному числу */
	gte?: number;
	/** Меньше указанного числа */
	lt?: number;
	/** Меньше или равно указанному числу */
	lte?: number;
	/** Не равно указанному числу */
	notEq?: number;
	/** Не больше указанного числа */
	notGt?: number;
	/** Не больше или равно указанному числу */
	notGte?: number;
	/** Не меньше указанного числа */
	notLt?: number;
	/** Не меньше или равно указанному числу */
	notLte?: number;
	/** Должно быть между двумя числами */
	between?: [
		number,
		number
	];
};
/**
 * # Условия для массивов (required)
  
   Позволяет определять условия для обязательных массивов в контексте.
   Не поддерживает проверку на null, так как required поля всегда имеют значение.
  
   ## Параметры:
   | Параметр    | Тип     | Описание                           |
   | ----------- | ------- | ---------------------------------- |
   | length      | number \| { min?: number; max?: number } | Длина массива |
   | includes    | T       | Содержит ли массив указанный элемент |
   | notIncludes | T       | Не содержит ли массив указанный элемент |
   | every       | Condition | Все элементы удовлетворяют условию |
   | some        | Condition | Хотя бы один элемент удовлетворяет условию |
   | isEmpty     | boolean | Является ли массив пустым          |
   
   @example
   ```typescript
   // Простое условие
   tags: ['admin', 'user']
   
   // Сложное условие
   tags: { length: { min: 1 } }
   scores: { every: { gte: 0 } }
   ```
   */
export type CondArrayRequired<T = any> = T[] | {
	/** Длина массива */
	length?: number | {
		min?: number;
		max?: number;
	};
	/** Содержит ли массив указанный элемент */
	includes?: T;
	/** Не содержит ли массив указанный элемент */
	notIncludes?: T;
	/** Все элементы удовлетворяют условию */
	every?: T extends number ? {
		gt?: number;
		gte?: number;
		lt?: number;
		lte?: number;
		eq?: number;
	} : T extends string ? {
		include?: string;
		startsWith?: string;
		endsWith?: string;
		pattern?: RegExp;
	} : never;
	/** Хотя бы один элемент удовлетворяет условию */
	some?: T extends number ? {
		gt?: number;
		gte?: number;
		lt?: number;
		lte?: number;
		eq?: number;
	} : T extends string ? {
		include?: string;
		startsWith?: string;
		endsWith?: string;
		pattern?: RegExp;
	} : never;
	/** Является ли массив пустым */
	isEmpty?: boolean;
};
/**
 * # Условия для массивов (optional)
  
   Позволяет определять условия для опциональных массивов в контексте.
   Поддерживает проверку на null.
  
   ## Параметры:
   | Параметр    | Тип     | Описание                           |
   | ----------- | ------- | ---------------------------------- |
   | null        | boolean | Является ли значение null          |
   | length      | number \| { min?: number; max?: number } | Длина массива |
   | includes    | T       | Содержит ли массив указанный элемент |
   | notIncludes | T       | Не содержит ли массив указанный элемент |
   | every       | Condition | Все элементы удовлетворяют условию |
   | some        | Condition | Хотя бы один элемент удовлетворяет условию |
   | isEmpty     | boolean | Является ли массив пустым          |
   
   @example
   ```typescript
   // Простое условие
   tags: ['admin', 'user']
   
   // Проверка на null
   tags: null
   
   // Сложное условие
   tags: { length: { min: 1 } }
   scores: { every: { gte: 0 } }
   ```
   */
export type CondArrayOptional<T = any> = T[] | null | {
	/** Является ли значение null */
	null?: boolean;
	/** Длина массива */
	length?: number | {
		min?: number;
		max?: number;
	};
	/** Содержит ли массив указанный элемент */
	includes?: T;
	/** Не содержит ли массив указанный элемент */
	notIncludes?: T;
	/** Все элементы удовлетворяют условию */
	every?: T extends number ? {
		gt?: number;
		gte?: number;
		lt?: number;
		lte?: number;
		eq?: number;
	} : T extends string ? {
		include?: string;
		startsWith?: string;
		endsWith?: string;
		pattern?: RegExp;
	} : never;
	/** Хотя бы один элемент удовлетворяет условию */
	some?: T extends number ? {
		gt?: number;
		gte?: number;
		lt?: number;
		lte?: number;
		eq?: number;
	} : T extends string ? {
		include?: string;
		startsWith?: string;
		endsWith?: string;
		pattern?: RegExp;
	} : never;
	/** Является ли массив пустым */
	isEmpty?: boolean;
};
/**
 * Условие для обязательного поля контекста
 */
export type Condition<T> = T extends boolean ? CondBooleanRequired : T extends string ? CondStringRequired : T extends number ? CondNumberRequired : T extends (infer U)[] ? CondArrayRequired<U> : T extends readonly (infer U)[] ? CondArrayRequired<U> : never;
/**
 * Условие для опционального поля контекста
 */
export type ConditionOptional<T> = T extends boolean ? CondBooleanOptional : T extends string ? CondStringOptional : T extends number ? CondNumberOptional : T extends (infer U)[] ? CondArrayOptional<U> : T extends readonly (infer U)[] ? CondArrayOptional<U> : T extends null ? null : never;
/**
 * Условие контекстного поля
 */
export type Conditions<C extends Schema = Schema> = {
	[K in keyof Partial<C>]: C[K] extends SchemaType<any, true, any, any> ? Condition<Values<C>[K]> : ConditionOptional<Values<C>[K]>;
};
/**
 * Состояние в которое можно перейти с условиями
 */
export type Transitions<To extends string = string, C extends Schema = Schema> = {
	[K in To]?: Conditions<C>;
};
/**
 * Декларативные условия фильтрации реакций
 *
 * Плоская структура с расширенными возможностями для meta и patch.
 * Позволяет фильтровать события по различным критериям.
 *
 * @example
 * ```typescript
 * const conditions: ReactionFilterConditions = {
 *   meta: "user",                   // Фильтр по мете актора
 *   op: "replace",                  // Фильтр по операции
 *   path: "/context",               // Фильтр по пути
 *   value: { gt: 0 },               // Фильтр по значению
 *   index: { gte: 0 },              // Фильтр по индексу
 *   timestamp: { gt: Date.now() }   // Фильтр по временной метке
 * }
 * ```
 */
export type ReactionFilterConditions = {
	/**
	 # Фильтрация по мете актора
	 
	 1. Прямое сравнение строки с условием
	  - meta: "test" - мета должна быть равна "test"
	  - meta: /test/ - мета должна соответствовать регулярному выражению /test/ (без кавычек)
	 
	 2. Сравнение с условием
	  - meta: { eq: "test" } - мета должна быть равна "test"
	  - meta: { pattern: /test/ } - мета должна соответствовать регулярному выражению /test/
  
	 Условия сравнения:
	 | Параметр       | Тип                                  | Описание                              |
	 | -------------- | ------------------------------------ | ------------------------------------- |
	 | startsWith     | string                               | Начинается ли с указанной строки      |
	 | endsWith       | string                               | Заканчивается ли на указанную строку  |
	 | include        | string                               | Включает ли указанную подстроку       |
	 | pattern        | RegExp                               | Шаблон регулярного выражения          |
	 | eq             | string                               | Равно указанной строке                |
	 | notEq          | string                               | Не равно указанной строке             |
	 | notInclude     | string                               | Не включает указанную подстроку       |
	 | notStartsWith  | string                               | Не начинается с указанной строки      |
	 | notEndsWith    | string                               | Не заканчивается на указанную строку  |
	 | length         | number \| { min?: number; max?: number } | Длина строки                      |
	 | between        | [string, string]                     | Должно быть между двумя строками      |
	 
	 @example
	 ```typescript
	 // Простые фильтры
	 meta: "user"
	 meta: /^user_/
	 
	 // Сложные фильтры
	 meta: {
	   startsWith: "user",
	   notInclude: "admin"
	 }
	 meta: {
	   pattern: /^[a-z]+_[0-9]+$/,
	   length: { min: 3, max: 20 }
	 }
	 ```
	*/
	meta?: CondStringRequired;
	/**
	 # Фильтрация по индексу
	 
	 1. Прямое сравнение числа с условием
	  - index: 5 - индекс должен быть равен 5
	 
	 2. Сравнение с условием
	  - index: { eq: 5 } - индекс должен быть равен 5
	  - index: { gt: 3 } - индекс должен быть больше 3
   
	 Условия сравнения:
	 | Параметр       | Тип                                  | Описание                              |
	 | -------------- | ------------------------------------ | ------------------------------------- |
	 | eq             | number                               | Равно указанному числу                |
	 | notEq          | number                               | Не равно указанному числу             |
	 | gt             | number                               | Больше указанного числа               |
	 | gte            | number                               | Больше или равно указанному числу     |
	 | lt             | number                               | Меньше указанного числа               |
	 | lte            | number                               | Меньше или равно указанному числу     |
	 | notGt          | number                               | Не больше указанного числа            |
	 | notGte         | number                               | Не больше или равно указанному числу  |
	 | notLt          | number                               | Не меньше указанного числа            |
	 | notLte         | number                               | Не меньше или равно указанному числу  |
	 | between        | [number, number]                     | Должно быть между двумя числами       |
	 
	 @example
	 ```typescript
	 // Простые фильтры
	 index: 0
	 index: { gt: 10 }
	 
	 // Сложные фильтры
	 index: {
	   gte: 0,
	   lte: 100
	 }
	 index: {
	   between: [1, 10],
	   notEq: 5
	 }
	 ```
	*/
	actor?: CondStringRequired;
	/**
	 # Фильтрация по временной метке
	 
	 1. Прямое сравнение числа с условием
	  - timestamp: 1640995200000 - временная метка должна быть равна 1640995200000
	 
	 2. Сравнение с условием
	  - timestamp: { eq: 1640995200000 } - временная метка должна быть равна 1640995200000
	  - timestamp: { gt: 1640995200000 } - временная метка должна быть больше 1640995200000
   
	 Условия сравнения:
	 | Параметр       | Тип                                  | Описание                              |
	 | -------------- | ------------------------------------ | ------------------------------------- |
	 | eq             | number                               | Равно указанному числу                |
	 | notEq          | number                               | Не равно указанному числу             |
	 | gt             | number                               | Больше указанного числа               |
	 | gte            | number                               | Больше или равно указанному числу     |
	 | lt             | number                               | Меньше указанного числа               |
	 | lte            | number                               | Меньше или равно указанному числу     |
	 | notGt          | number                               | Не больше указанного числа            |
	 | notGte         | number                               | Не больше или равно указанному числу  |
	 | notLt          | number                               | Не меньше указанного числа            |
	 | notLte         | number                               | Не меньше или равно указанному числу  |
	 | between        | [number, number]                     | Должно быть между двумя числами       |
	 
	 @example
	 ```typescript
	 // Фильтры по времени
	 timestamp: { gt: Date.now() - 60000 }  // Последняя минута
	 timestamp: {
	   gte: Date.now() - 3600000,           // Последний час
	   lte: Date.now()
	 }
	 ```
	*/
	timestamp?: CondNumberRequired;
	/**
	 # Фильтрация по операции патча
	 
	 Доступные операции:
	 | Операция       | Описание                              |
	 | -------------- | ------------------------------------- |
	 | replace        | Замена значения по указанному пути    |
	 | add            | Добавление нового значения по пути     |
	 | remove         | Удаление значения по указанному пути   |
	 | test           | Проверка значения по указанному пути   |
	 
	 Примеры использования:
	 - op: "replace" - операция должна быть replace
	 - op: "add" - операция должна быть add
	 
	 @example
	 ```typescript
	 // Фильтры по операции
	 op: "replace"  // Только замены
	 op: "add"      // Только добавления
	 op: "remove"   // Только удаления
	 ```
	*/
	op?: "replace" | "add" | "remove" | "test";
	/**
	 # Фильтрация по пути патча
	 
	 Доступные пути:
	 | Путь           | Описание                              |
	 | -------------- | ------------------------------------- |
	 | /context       | Путь к контексту актора               |
	 | /state         | Путь к состоянию актора               |
	 | /              | Корневой путь (полный объект актора)  |
	 
	 Примеры использования:
	 - path: "/context" - путь должен быть /context
	 - path: "/state" - путь должен быть /state
	 
	 @example
	 ```typescript
	 // Фильтры по пути
	 path: "/context"  // Только изменения контекста
	 path: "/state"    // Только изменения состояния
	 path: "/"         // Любые изменения
	 ```
	*/
	path?: "/context" | "/state" | "/";
	/**
	 # Фильтрация по значению патча
	 
	 Поддерживает все типы значений с расширенными условиями сравнения.
	 
	 ## Строковые значения
	 
	 1. Прямое сравнение
	  - value: "active" - значение должно быть равно "active"
	  - value: /test/ - значение должно соответствовать регулярному выражению
	 
	 2. Расширенные условия
	 
	 | Параметр       | Тип                                  | Описание                              |
	 | -------------- | ------------------------------------ | ------------------------------------- |
	 | eq             | string                               | Равно указанной строке                |
	 | notEq          | string                               | Не равно указанной строке             |
	 | startsWith     | string                               | Начинается ли с указанной строки      |
	 | endsWith       | string                               | Заканчивается ли на указанную строку  |
	 | include        | string                               | Включает ли указанную подстроку       |
	 | notInclude     | string                               | Не включает указанную подстроку       |
	 | notStartsWith  | string                               | Не начинается с указанной строки      |
	 | notEndsWith    | string                               | Не заканчивается на указанную строку  |
	 | pattern        | RegExp                               | Шаблон регулярного выражения          |
	 | length         | number \| { min?: number; max?: number } | Длина строки                      |
	 | between        | [string, string]                     | Должно быть между двумя строками      |
	 
	 ## Числовые значения
	 
	 1. Прямое сравнение
	  - value: 42 - значение должно быть равно 42
	 
	 2. Расширенные условия
	 
	 | Параметр | Тип              | Описание                              |
	 | -------- | ---------------- | ------------------------------------- |
	 | eq       | number           | Равно указанному числу                |
	 | notEq    | number           | Не равно указанному числу             |
	 | gt       | number           | Больше указанного числа               |
	 | gte      | number           | Больше или равно указанному числу     |
	 | lt       | number           | Меньше указанного числа               |
	 | lte      | number           | Меньше или равно указанному числу     |
	 | notGt    | number           | Не больше указанного числа            |
	 | notGte   | number           | Не больше или равно указанному числу  |
	 | notLt    | number           | Не меньше указанного числа            |
	 | notLte   | number           | Не меньше или равно указанному числу  |
	 | between  | [number, number] | Должно быть между двумя числами       |
	 
	 ## Булевы значения
	 
	 1. Прямое сравнение
	  - value: true - значение должно быть true
	 
	 2. Расширенные условия
	 
	 | Параметр   | Тип     | Описание                           |
	 | ---------- | ------- | ---------------------------------- |
	 | eq         | boolean | Равно указанному булеву значению   |
	 | notEq      | boolean | Не равно указанному булеву значению|
	 | logicalEq  | boolean | Логическое равенство               |
	 
	 ## Массивы
	 
	 1. Прямое сравнение
	  - value: [1, 2, 3] - массив должен быть равен [1, 2, 3]
	 
	 2. Расширенные условия
	 
	 | Параметр    | Тип              | Описание                              |
	 | ----------- | ---------------- | ------------------------------------- |
	 | length      | number \| { min?: number; max?: number } | Длина массива                    |
	 | includes    | any              | Содержит ли массив указанный элемент  |
	 | notIncludes | any              | Не содержит ли массив указанный элемент|
	 | every       | { gt?: number; gte?: number; lt?: number; lte?: number; eq?: number; include?: string } | Все элементы удовлетворяют условию |
	 | some        | { gt?: number; gte?: number; lt?: number; lte?: number; eq?: number; include?: string } | Хотя бы один элемент удовлетворяет условию |
	 | isEmpty     | boolean          | Является ли массив пустым             |
	 
	 ## Null и undefined
	 
	 | Параметр | Тип     | Описание                    |
	 | -------- | ------- | --------------------------- |
	 | null     | boolean | Является ли значение null   |
	 
	 ## Объекты
	 
	 - value: { name: "test" } - объект должен быть равен { name: "test" }
	 
	 ## Комбинированные условия
	 
	 Можно комбинировать с другими фильтрами:
	 ```typescript
	 filter({
	   value: { gt: 10, lt: 100 },
	   op: "replace",
	   path: "/context"
	 })
	 ```
	 
	 @example
	 ```typescript
	 // Простые фильтры
	 value: "active"
	 value: 42
	 value: true
	 value: [1, 2, 3]
	 
	 // Сложные фильтры
	 value: {
	   gt: 0,
	   lt: 100
	 }
	 value: {
	   startsWith: "user",
	   length: { min: 3 }
	 }
	 value: {
	   includes: "admin",
	   length: { min: 1 }
	 }
	 ```
	*/
	value?: Condition<any> | ConditionOptional<any>;
};
export type ReactionParams = {
	meta: string;
	actor: string;
	timestamp: number;
	patch: JsonPatch;
	self: Self;
};
/**
 * Конфигурация одной реакции
 *
 * Содержит название, описание, функцию фильтрации и функцию обновления.
 *
 * @template C - схема контекста
 * @template S - строковые ключи состояний
 * @template Core - тип core объекта
 *
 * @example
 * ```typescript
 * const reaction: Reaction<MyContext, "idle" | "loading"> = {
 *   label: "Обработка сообщений",
 *   desc: "Обрабатывает входящие сообщения от пользователей",
 *   filter: ({ meta, patch }) => {
 *     return meta === "user" && patch.op === "replace"
 *   },
 *   update: ({ update, context, patch }) => {
 *     update({
 *       lastMessage: patch.value,
 *       messageCount: context.messageCount + 1
 *     })
 *   }
 * }
 * ```
 */
export type Reaction<C extends Schema, S extends string, I extends Core> = {
	/** Название реакции для документации */
	label: string;
	/** Описание реакции для документации */
	desc?: string;
	/** Функция фильтрации событий */
	filter: (args: ReactionParams) => boolean;
	/** Функция обработки события */
	update: ReactionAction<C, S, I>;
};
/**
 * Цепочка для создания массива реакций
 *
 * Позволяет создавать массив реакций с группировкой по состояниям.
 *
 * @template C - схема контекста
 * @template S - строковые ключи состояний
 * @template Core - тип core объекта
 *
 * @example
 * ```typescript
 * const reactions: ReactionsChain<MyContext, "idle" | "loading"> = (reaction) => [
 *   [
 *     ["idle", "loading"], // Состояния
 *     reaction({ label: "Обработка сообщений" })
 *       .filter(({ self }) => ({ meta: "user", actor: self.actor.split("/")[1] }))
 *       .equal(({ update, patch, self }) => {
 *         update({ lastMessage: patch.value })
 *         // self.destroy() доступен в equal, но не в filter
 *       })
 *   ]
 * ]
 * ```
 */
export type ReactionsDeclaration<C extends Schema, S extends string, I extends Core> = (reaction: (config?: {
	/** Название реакции */
	label?: string;
	/** Описание реакции */
	desc?: string;
}) => {
	/** Добавляет декларативные фильтры (использует SelfInfo без destroy) */
	filter: (filter: (params: {
		self: SelfInfo;
		context: Values<C>;
	}) => ReactionFilterConditions) => {
		/** Добавляет функцию обработки события (использует Self с destroy) */
		equal: (reaction: ReactionAction<C, S, I>) => Reaction<C, S, I> & {
			/** Метод для регистрации состояний */
			registerStates: (states: S[]) => void;
		};
	};
}) => ReactionsChainResult<C, S, I>; /**

/** Схема реакций */
export type ReactionsSchema = {
	reactions: Record<string, {
		label: string;
		desc?: string;
		cond: string;
		read?: string[];
		write?: string[];
		src: string;
	}>;
	states: Record<string, string[]>;
}; /**
 * Функция обновления контекста
 *
 * Вызывается когда реакция срабатывает и фильтр прошел успешно.
 * Получает все необходимые данные для обработки события.
 *
 * @template C - схема контекста
 * @template S - строковые ключи состояний
 * @template Core - тип core объекта
 *
 * @includeExample ./react/test/reactions.basic.spec.ts
 * @includeExample ./react/test/reactions.execution.spec.ts
 *
 * @example
 * ```typescript
 * const updateFn: ReactionUpdate<MyContext, "idle" | "loading"> = ({
 *   update,    // Функция для обновления контекста
 *   context,   // Текущий контекст
 *   core,      // Core объект
 *   meta,      // Мета-информация отправителя
 *   actor,     // ID актора-отправителя
 *   timestamp, // Временная метка
 *   patch,     // Патч данных
 *   state,     // Текущее состояние
 *   self       // Полный идентификатор актора с destroy
 * }) => {
 *   // Обработка события
 *   update({
 *     lastMessage: patch.value,
 *     messageCount: context.messageCount + 1
 *   })
 *   // self.destroy() доступен для уничтожения актора
 * }
 * ```
 */
export type ReactionAction<C extends Schema, S extends string, I extends Core> = (args: {
	/** Функция для обновления контекста */
	update: Update<C>;
	/** Текущий контекст */
	context: Values<C>;
	/** Core объект */
	core: I;
	/** Хеш меты компонента-актора */
	meta: string;
	/** Информация об акторе */
	actor: string;
	/** Временная метка */
	timestamp: number;
	/** Патч для применения к актору */
	patch: JsonPatch;
	/** Текущее состояние */
	state: S;
	/** Идентификатор актора с методом destroy */
	self: Self;
}) => void; /** Результат цепочки реакций */
export type ReactionsChainResult<C extends Schema, S extends string, I extends Core> = [
	S[],
	Reaction<C, S, I> & {
		/** Метод для регистрации состояний */
		registerStates: (states: S[]) => void;
	}
][];
/**ƒ
 * Конфигурация состояний
 *
 * @includeExample ./state/test/states.config.basic.spec.ts
 * @includeExample ./state/test/states.config.order.spec.ts
 * @includeExample ./state/test/states.config.numeric.spec.ts
 * @includeExample ./state/test/states.config.multiple.spec.ts
 */
export type StatesConfig<S extends string = string, C extends Schema = Schema> = Record<S, Transitions<S, C>>;
/**
 *  Ядро компонента
 */
/**
 * Ядро актора - объект для хранения сложных данных
 *
 * Используется для хранения данных, которые не подходят для контекста:
 * - Сложные объекты и структуры данных
 * - Кэшированные результаты вычислений
 * - Внешние ресурсы (DOM элементы, WebSocket соединения)
 * - Состояние, которое не влияет на UI напрямую
 *
 * @example
 * ```typescript
 * const core: Core = {
 *   users: [],
 *   cache: new Map(),
 *   socket: new WebSocket("ws://localhost:8080"),
 *   domElement: document.getElementById("container")
 * }
 * ```
 */
export type Core = Record<string, any>;
export type JsonPatch = {
	op: "replace" | "add" | "remove" | "test";
	path: string;
	value?: any;
};
// Generated by dts-bundle-generator v9.5.1
/**
 * Статическое строковое значение.
 * @group Варианты значений
 */
export type ValueStatic = string;
/**
 * Переменный атрибут с путем к данным.
 * Используется для простых динамических атрибутов.
 *
 * @group Варианты значений
 * @example
 * ```html
 * <div class=${context.theme}>Тема пользователя</div>
 * ```
 */
export type ValueVariable = {
	/**
	 * Путь к данным в контексте
	 * @example
	 * ```typescript
	 * data: "/context/theme"
	 * ```
	 *
	 * Путь к данным в ядре
	 * @example
	 * ```typescript
	 * data: "/core/theme"
	 * ```
	 *
	 * Путь к данным инстанса map
	 * @example
	 * ```typescript
	 * data: "[item]/theme"
	 * ```
	 *
	 * Путь к данным родительского инстанса из вложенного map
	 * @example
	 * ```typescript
	 * data: "../[item]/theme"
	 * ```
	 *
	 * Путь к индексу map
	 * @example
	 * ```typescript
	 * data: "[index]"
	 * ```
	 *
	 * Путь к индексу родительского инстанса из вложенного map
	 * @example
	 * ```typescript
	 * data: "../[index]"
	 * ```
	 */
	data: string;
};
/**
 * Динамический атрибут с выражением и путем к данным.
 * Используется для сложных вычислений в атрибутах.
 *
 * @group Варианты значений
 * @example
 * ```html
 * <div class=${core.role === 'admin' ? 'admin-panel' : 'user-panel'}>
 *   Панель управления
 * </div>
 * ```
 */
export type ValueDynamic = {
	/**
	 * Путь к данным в контексте
	 * @example
	 * ```typescript
	 * data: "/context/theme"
	 * ```
	 *
	 * Путь к данным в ядре
	 * @example
	 * ```typescript
	 * data: "/core/theme"
	 * ```
	 *
	 * Путь к данным инстанса map
	 * @example
	 * ```typescript
	 * data: "[item]/theme"
	 * ```
	 *
	 * Путь к данным родительского инстанса из вложенного map
	 * @example
	 * ```typescript
	 * data: "../[item]/theme"
	 * ```
	 *
	 * Путь к индексу map
	 * @example
	 * ```typescript
	 * data: "[index]"
	 * ```
	 *
	 * Путь к индексу родительского инстанса из вложенного map
	 * @example
	 * ```typescript
	 * data: "../[index]"
	 * ```
	 *
	 * Пути к данным
	 * @example
	 * ```typescript
	 * data: ["/context/theme", "[item]/theme", "../[item]/theme", "[index]/theme", "../[index]/theme"]
	 * ```
	 */
	data: string | string[];
	/**
	 * Выражение с переменными в data (по индексу массива)
	 *
	 * @example
	 * ```typescript
	 * expr: "${[0]} === 'admin' ? 'admin' : 'user'"
	 * ```
	 */
	expr: string;
};
/**
 * Массивы атрибутов.
 * Используется для атрибутов, которые могут содержать несколько значений (class, rel).
 *
 * @group Значения атрибутов
 * @example
 * ```html
 * <div class="container ${context.theme} ${context.isActive && 'active'}">
 *   Элемент с несколькими классами
 * </div>
 * ```
 */
export type ValueArray = ValueStatic | ValueVariable | ValueDynamic;
/**
 * Булевые атрибуты.
 * HTML атрибуты, которые присутствуют или отсутствуют (hidden, disabled, checked).
 *
 * @group Значения атрибутов
 * @example
 * ```html
 * <input type="checkbox" ${core.user.isSubscribed && "checked"} />
 * <button ${!context.canSubmit && "disabled"}>Отправить</button>
 * <div ${!context.isVisible && "hidden"}>Скрытый контент</div>
 * ```
 */
export type ValueBoolean = boolean | ValueVariable | ValueDynamic;
/**
 * Событийные атрибуты.
 * Содержит обработчики событий (onclick, onchange, onsubmit и т.д.)
 *
 * @group Значения атрибутов
 * @example Простая функция без параметров
 * ```html
 * <button onclick=${core.handleClick}>Кнопка</button>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "onclick": {
 *     "data": "/core/handleClick"
 *   }
 * }
 * ```
 *
 * @example Функция с параметрами
 * ```html
 * <input onchange=${(e) => update({ value: e.target.value })} />
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "onchange": {
 *     "upd": "value",
 *     "expr": "(e) => update({ value: e.target.value })"
 *   }
 * }
 * ```
 *
 * @example Событие в массиве
 * ```html
 * <li onclick=${() => core.item.onClick()}>${core.item.name}</li>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "onclick": {
 *     "data": "/core/item/onClick",
 *     "expr": "() => ${[0]}()"
 *   }
 * }
 * ```
 */
export type ValueEvent = {
	/** Обновляемые ключи контекста в функции Update */
	upd?: string | string[];
	/**
	 * Путь(и) к данным для выражения
	 *
	 * @example
	 * ```typescript
	 * data: "/context/value"
	 * data: ["/context/value", "[item]/nested/variable"]
	 * ```
	 */
	data: string | string[];
	/**
	 * Выражение с индексами
	 *
	 * @example
	 * ```typescript
	 * expr: "${[0]} === 'admin' ? 'admin' : 'user'"
	 * ```
	 */
	expr: string;
} | {
	/** Обновляемые ключи контекста в функции Update */
	upd?: string | string[];
	/**
	 * Выражение с индексами
	 *
	 * @example
	 * ```typescript
	 * expr: "${[0]} === 'admin' ? 'admin' : 'user'"
	 * ```
	 */
	expr: string;
} | {
	/**
	 * Путь(и) к данным для выражения
	 *
	 * @example
	 * ```typescript
	 * data: "/context/value"
	 * data: ["/context/value", "[item]/nested/variable"]
	 * ```
	 */
	data: string | string[];
};
/**
 * Строковые атрибуты.
 * Обычные HTML атрибуты со строковыми значениями.
 *
 * @group Значения атрибутов
 * @example
 * ```html
 * <img src=${context.url} alt=${context.alt} title=${context.title} />
 * <a href="/user/${core.user.id}">Профиль пользователя</a>
 * ```
 */
export type ValueString = ValueStatic | ValueVariable | ValueDynamic;
/**
 * Объект стилей.
 * CSS стили в виде JavaScript объекта (styled-components подход).
 *
 * @group Значения атрибутов
 * @example Простой объект стилей
 * ```html
 * <div style=${{backgroundColor: "red", color: "white"}}>
 *   Стилизованный элемент
 * </div>
 * ```
 *
 * @example Динамические стили
 * ```html
 * <div style=${{backgroundColor: core.theme.primary, color: core.theme.text}}>
 *   Элемент с темой
 * </div>
 * ```
 *
 * @example Условные стили
 * ```html
 * <div style=${{backgroundColor: context.isActive ? "green" : "red", color: "white"}}>
 *   Условный стиль
 * </div>
 * ```
 */
export type ValueStyle = ValueStatic | ValueVariable | ValueDynamic;
export interface Attributes {
	/** События (onclick, onchange, onsubmit и т.д.) */
	event?: Record<string, ValueEvent>;
	/** Булевые атрибуты (hidden, disabled, checked, readonly и т.д.) */
	boolean?: Record<string, ValueBoolean>;
	/** Массивы атрибутов (class, rel, ping и т.д.) */
	array?: Record<string, ValueArray[]>;
	/** Строковые атрибуты (id, title, alt, href и т.д.) */
	string?: Record<string, ValueString>;
	/** Стили (CSS в виде строки или объекта) */
	style?: Record<string, ValueStyle>;
}
/**
 * Узел HTML элемента в AST.
 * Представляет HTML тег с атрибутами и дочерними элементами.
 *
 * @group Nodes
 * @example
 * ```html
 * <div class="container" id="main">
 *   <h1>Заголовок</h1>
 *   <p>Текст</p>
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "string": {
 *     "class": "container",
 *     "id": "main"
 *   },
 *   "child": [
 *     {
 *       "tag": "h1",
 *       "type": "el",
 *       "child": [
 *         {
 *           "type": "text",
 *           "value": "Заголовок"
 *         }
 *       ]
 *     },
 *     {
 *       "tag": "p",
 *       "type": "el",
 *       "child": [
 *         {
 *           "type": "text",
 *           "value": "Текст"
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * Структура узла:
 * - `tag` - имя HTML тега
 * - `type` - всегда "el" для элементов
 * - `child` - массив дочерних узлов
 * - Атрибуты: `event`, `boolean`, `array`, `string`, `style`
 */
export interface NodeElement extends Attributes {
	/**
	 * Имя HTML тега
	 *
	 * @example
	 * ```typescript
	 * tag: "div"
	 * ```
	 *
	 * @example
	 * ```typescript
	 * tag: "button"
	 * ```
	 */
	tag: string;
	/**
	 * Тип узла - всегда "el" для элементов
	 *
	 * @example
	 * ```typescript
	 * type: "el"
	 * ```
	 */
	type: "el";
	/**
	 * Дочерние узлы элемента (могут быть любого типа Node)
	 *
	 * @example
	 * ```typescript
	 * child: [
	 *   { type: "text", value: "Привет" },
	 *   { type: "text", data: "/context/user/name" }
	 * ]
	 * ```
	 */
	child?: NodeType[];
}
/**
 * Мета-узел в AST.
 *
 * Представляет meta-элемент.
 * Поддерживает создание компонентов с динамическими именами тегов.
 *
 * @group Nodes
 * @example Статический мета-тег
 * ```html
 * <meta-component class="custom">
 *   <p>Содержимое компонента</p>
 * </meta-component>
 * ```
 *
 * @example Динамический мета-тег
 * ```html
 * <meta-${core.actorHash} class="dynamic">
 *   <p>Динамический компонент</p>
 * </meta-${core.actorHash}>
 * ```
 *
 * @example Мета-элемент с core и context
 * ```html
 * <meta-widget core=${core.widgetConfig} context=${core.userData}>
 *   <div>Виджет с конфигурацией</div>
 * </meta-widget>
 * ```
 *
 * Структура узла:
 * - `type` - всегда "meta" для мета-узлов
 * - `tag` - имя мета-тега (статическое или динамическое)
 * - `child` - дочерние элементы (опционально)
 * - Атрибуты: `event`, `boolean`, `array`, `string`, `style`
 * - Свойства: `core`, `context`
 */
export interface NodeMeta extends Attributes {
	/** Имя мета-тега (может быть статическим или динамическим) */
	tag: ValueStatic | ValueDynamic | ValueVariable;
	/** Тип узла - всегда "meta" для мета-узлов */
	type: "meta";
	/** Дочерние элементы (опционально) */
	child?: NodeType[];
	/** Core свойство для meta-компонентов (передача core объекта) */
	core?: ValueStatic | ValueDynamic | ValueVariable;
	/** Context свойство для meta-компонентов (передача context объекта) */
	context?: ValueStatic | ValueDynamic | ValueVariable;
}
/**
 * Узел условного оператора в AST.
 * Представляет тернарный оператор с ветками true и false.
 *
 * @group Nodes
 * @example Простое условие
 * ```html
 * <div>
 *   ${context.isLoggedIn ? html`<span>Добро пожаловать, ${context.name}!</span>` : html`<a href="/login">Войти</a>`}
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "cond",
 *       "data": "/context/isLoggedIn",
 *       "child": [
 *         {
 *           "tag": "span",
 *           "type": "el",
 *           "child": [
 *             {
 *               "type": "text",
 *               "data": "/context/name",
 *               "expr": "Добро пожаловать, ${[0]}!"
 *             }
 *           ]
 *         },
 *         {
 *           "tag": "a",
 *           "type": "el",
 *           "string": {
 *             "href": "/login"
 *           },
 *           "child": [
 *             {
 *               "type": "text",
 *               "value": "Войти"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * @example Сложное условие
 * ```html
 * <div>
 *   ${core.role === 'admin' && core.permissions.includes('write') ?
 *     html`<button>Редактировать</button>` :
 *     html`<span>Нет прав</span>`
 *   }
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "cond",
 *       "data": ["user.role", "user.permissions"],
 *       "expr": "${[0]} === 'admin' && ${[1]}.includes('write')",
 *       "child": [
 *         {
 *           "tag": "button",
 *           "type": "el",
 *           "child": [
 *             {
 *               "type": "text",
 *               "value": "Редактировать"
 *             }
 *           ]
 *         },
 *         {
 *           "tag": "span",
 *           "type": "el",
 *           "child": [
 *             {
 *               "type": "text",
 *               "value": "Нет прав"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * @example Условие с проверкой массива
 * ```html
 * <div>
 *   ${core.posts.length > 0 ?
 *     html`<ul>${core.posts.map(post => html`<li>${post.title}</li>`)}</ul>` :
 *     html`<p>Постов пока нет</p>`
 *   }
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "cond",
 *       "data": "/core/posts.length",
 *       "expr": "${[0]} > 0",
 *       "child": [
 *         {
 *           "tag": "ul",
 *           "type": "el",
 *           "child": [
 *             {
 *               "type": "map",
 *               "data": "/core/posts",
 *               "child": [
 *                 {
 *                   "tag": "li",
 *                   "type": "el",
 *                   "child": [
 *                     {
 *                       "type": "text",
 *                       "data": "[item]/title"
 *                     }
 *                   ]
 *                 }
 *               ]
 *             }
 *           ]
 *         },
 *         {
 *           "tag": "p",
 *           "type": "el",
 *           "child": [
 *             {
 *               "type": "text",
 *               "value": "Постов пока нет"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * Структура узла:
 * - `type` - всегда "cond" для условных операторов
 * - `data` - путь(и) к данным для условия
 * - `expr` - выражение с индексами (если условие сложное)
 * - `child` - массив из двух элементов: [true-ветка, false-ветка]
 */
export interface NodeCondition {
	/** Тип узла - всегда "cond" для условных операторов */
	type: "cond";
	/**
	 * Путь(и) к данным для условия
	 *
	 * @example Простой путь
	 * ```typescript
	 * data: "/context/isLoggedIn"
	 * ```
	 *
	 * ---
	 *
	 * @example Массив путей
	 * ```typescript
	 * data: ["/context/isAdmin", "/core/role"]
	 * ```
	 */
	data: string | string[];
	/**
	 * Выражение с индексами (если условие сложное)
	 *
	 * @example
	 * ```typescript
	 * expr: "${[0]} === 'admin' && ${[1]}.length > 0"
	 * ```
	 */
	expr?: string;
	/** Узлы для случая когда условие истинно и ложно
	 * - true: первый элемент массива (child[0])
	 * - false: второй элемент массива (child[1])
	 */
	child: NodeType[];
}
/**
 * Узел логического оператора в AST.
 * Представляет логический оператор && с условным отображением.
 *
 * @group Nodes
 * @example Простое логическое условие
 * ```html
 * <div>
 *   ${context.isAdmin && html`<button>Админ-панель</button>`}
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "log",
 *       "data": "/context/isAdmin",
 *       "child": [
 *         {
 *           "tag": "button",
 *           "type": "el",
 *           "child": [
 *             {
 *               "type": "text",
 *               "value": "Админ-панель"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * @example Логическое условие с проверкой массива
 * ```html
 * <div>
 *   ${core.notifications.length > 0 && html`
 *     <div class="notifications">
 *       ${core.notifications.map(n => html`<div>${n.message}</div>`)}
 *     </div>
 *   `}
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "log",
 *       "data": "/core/notifications.length",
 *       "expr": "${[0]} > 0",
 *       "child": [
 *         {
 *           "tag": "div",
 *           "type": "el",
 *           "string": {
 *             "class": "notifications"
 *           },
 *           "child": [
 *             {
 *               "type": "map",
 *               "data": "/core/notifications",
 *               "child": [
 *                 {
 *                   "tag": "div",
 *                   "type": "el",
 *                   "child": [
 *                     {
 *                       "type": "text",
 *                       "data": "[item]/message"
 *                     }
 *                   ]
 *                 }
 *               ]
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * ### Сложное логическое условие
 *
 * {@includeCode ./logical.spec.ts#parse}
 * {@includeCode ./logical.spec.ts#expect}
 *
 * Структура узла:
 * - `type` - всегда "log" для логических операторов
 * - `data` - путь(и) к данным для условия
 * - `expr` - выражение с индексами (если условие сложное)
 * - `child` - дочерние узлы, которые отображаются только если условие истинно
 */
export interface NodeLogical {
	/** Тип узла - всегда "log" для логических операторов */
	type: "log";
	/**
	 * Путь(и) к данным для условия
	 *
	 * @example Простой путь
	 * ```typescript
	 * data: "/context/isAdmin"
	 * ```
	 *
	 * ---
	 *
	 * @example Массив путей
	 * ```typescript
	 * data: ["/context/notifications", "/context/count"]
	 * ```
	 */
	data: string | string[];
	/**
	 * Выражение с индексами (если условие сложное)
	 *
	 * @example
	 * ```typescript
	 * expr: "${[0]} === 'admin' && ${[1]}.includes('delete')"
	 * ```
	 */
	expr?: string;
	/** Дочерние узлы, которые отображаются только если условие истинно */
	child: NodeType[];
}
/**
 * Текстовый узел в AST.
 *
 * Узел может представлять:
 * - **статическое значение** (`value`),
 * - **динамическое значение** (один или несколько путей в `data`),
 * - **смешанное выражение** (динамика + статический текст, в `expr`).
 *
 * ## Структура
 * - `type` — всегда `"text"`
 * - `value` — строка, если узел статический
 * - `data` — строка или массив строк, если узел динамический
 * - `expr` — строка-шаблон с индексами `${_[i]}`, если текст смешанный
 *
 * ## Примеры
 *
 * ### Статический
 * {@includeCode ./text.spec.ts#static}
 * {@includeCode ./text.spec.ts#expectStatic}
 *
 * ### Динамический
 * {@includeCode ./text.spec.ts#dynamic}
 * {@includeCode ./text.spec.ts#expectDynamic}
 *
 * ### Смешанный
 * {@includeCode ./text.spec.ts#mixed}
 * {@includeCode ./text.spec.ts#expectMixed}
 *
 * ### Методы
 * {@includeCode ./text.spec.ts#methods}
 * {@includeCode ./text.spec.ts#expectMethods}
 *
 * ### Математический
 * {@includeCode ./text.spec.ts#mathematical}
 * {@includeCode ./text.spec.ts#expectMathematical}
 *
 * ### Логический
 * {@includeCode ./text.spec.ts#logical}
 * {@includeCode ./text.spec.ts#expectLogical}
 *
 * ### Логический литерал
 * {@includeCode ./text.spec.ts#logicalLiteral}
 * {@includeCode ./text.spec.ts#expectLogicalLiteral}
 *
 * ### Тернарный
 * {@includeCode ./text.spec.ts#ternary}
 * {@includeCode ./text.spec.ts#expectTernary}
 *
 * ### Тернарный литерал
 * {@includeCode ./text.spec.ts#ternaryLiteral}
 * {@includeCode ./text.spec.ts#expectTernaryLiteral}
 *
 * @group Nodes
 */
export interface NodeText {
	/** Тип узла — всегда `"text"` */
	type: "text";
	/** Путь или список путей к данным. */
	data?: string | string[];
	/** Статическое значение (если текст полностью статический). */
	value?: string;
	/**
	 * Выражение с индексами (если текст смешанный или содержит операторы).
	 *
	 * Индексы (`_[0]`, `_[1]`) ссылаются на элементы массива `data`.
	 */
	expr?: string;
}
/**
 * Узел map операции в AST.
 * Представляет итерацию по массиву данных с дочерними элементами.
 *
 * ### Примитивы
 * {@includeCode ./test/map/text.test.ts#itemValue}
 * {@includeCode ./test/map/text.test.ts#expectItemValue}
 *
 * ### Объекты
 * Могут быть как с деструктуризацией, так и без.
 * {@includeCode ./test/map/text.test.ts#objectValues}
 * {@includeCode ./test/map/text.test.ts#objectDestructValues}
 * {@includeCode ./test/map/text.test.ts#expectObjectValues}
 *
 * @example Итерация с индексом
 * ```html
 * <ul>
 *   ${core.items.map((item, index) => html`
 *     <li class=${index % 2 === 0 ? 'even' : 'odd'}>
 *       ${index + 1}. ${item.name}
 *     </li>
 *   `)}
 * </ul>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "ul",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "map",
 *       "data": "/core/items",
 *       "child": [
 *         {
 *           "tag": "li",
 *           "type": "el",
 *           "string": {
 *             "class": {
 *               "data": ["index", "item.name"],
 *               "expr": "${[0]} % 2 === 0 ? 'even' : 'odd'"
 *             }
 *           },
 *           "child": [
 *             {
 *               "type": "text",
 *               "data": ["index", "item.name"],
 *               "expr": "${[0] + 1}. ${[1]}"
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * @example Вложенная итерация
 * ```html
 * <div>
 *   ${core.categories.map(category => html`
 *     <section>
 *       <h1>${category.name}</h1>
 *       ${category.products.map(product => html`
 *         <div>${product.name}</div>
 *       `)}
 *     </section>
 *   `)}
 * </div>
 * ```
 *
 * Результат:
 * ```json
 * {
 *   "tag": "div",
 *   "type": "el",
 *   "child": [
 *     {
 *       "type": "map",
 *       "data": "/core/categories",
 *       "child": [
 *         {
 *           "tag": "section",
 *           "type": "el",
 *           "child": [
 *             {
 *               "tag": "h1",
 *               "type": "el",
 *               "child": [
 *                 {
 *                   "type": "text",
 *                   "data": "[item]/name"
 *                 }
 *               ]
 *             },
 *             {
 *               "type": "map",
 *               "data": "[item]/products",
 *               "child": [
 *                 {
 *                   "tag": "div",
 *                   "type": "el",
 *                   "child": [
 *                     {
 *                       "type": "text",
 *                       "data": "[item]/name"
 *                     }
 *                   ]
 *                 }
 *               ]
 *             }
 *           ]
 *         }
 *       ]
 *     }
 *   ]
 * }
 * ```
 *
 * Структура узла:
 * - `type` - всегда "map" для map операций
 * - `data` - путь к массиву данных для итерации
 * - `child` - дочерние узлы, которые будут повторены для каждого элемента массива
 * @group Nodes
 */
export interface NodeMap {
	/**
	 * Тип узла - всегда "map" для map операций
	 *
	 * @example
	 * ```typescript
	 * type: "map"
	 * ```
	 */
	type: "map";
	/**
	 * Путь к массиву данных для итерации
	 *
	 * @example Простой путь
	 * ```typescript
	 * data: "/context/users"
	 * ```
	 *
	 * @example Вложенный путь
	 * ```typescript
	 * data: "/core/products"
	 * ```
	 */
	data: string;
	/**
	 * Дочерние узлы, которые будут повторены для каждого элемента массива
	 *
	 * @example
	 * ```typescript
	 * child: [
	 *   {
	 *     tag: "li",
	 *     type: "el",
	 *     child: [
	 *       { type: "text", data: "[item]/name" }
	 *     ]
	 *   }
	 * ]
	 * ```
	 */
	child: NodeType[];
}
/**
 * Объединенный тип всех возможных узлов парсера.
 * Представляет любую структуру, которая может быть получена в результате парсинга HTML-шаблона.
 *
 * @group Nodes
 * @example Структура с различными типами узлов
 * ```html
 * <div class="container">
 *   <h1>${context.title}</h1>
 *   ${context.isLoggedIn ?
 *     html`<span>Добро пожаловать!</span>` :
 *     html`<a href="/login">Войти</a>`
 *   }
 *   ${core.notifications.length > 0 && html`
 *     <ul>
 *       ${core.notifications.map(n => html`<li>${n.message}</li>`)}
 *     </ul>
 *   `}
 *   <meta-component core="config" context="userData">
 *     <p>Содержимое компонента</p>
 *   </meta-component>
 * </div>
 * ```
 *
 * Результат парсинга будет содержать:
 * - NodeElement для div, h1, span, a, ul, li, p
 * - NodeText для статического текста и динамических значений
 * - NodeCondition для тернарного оператора
 * - NodeLogical для логического оператора &&
 * - NodeMap для итерации по массиву
 * - NodeMeta для meta-component
 */
export type NodeType = NodeMap | NodeCondition | NodeLogical | NodeText | NodeElement | NodeMeta;
/**
 * MetaFor — фабрика для создания web-компонента-актора конечного автомата
 * @param name - имя актора (используется для создания тега `meta-${name}`)
 * @returns chain API: context() -> states() -> core() -> processes() -> reactions() -> view()
 *
 * **Важно:** Итоговый тег компонента формируется как `meta-${name}`,
 * где name — это имя компонента, переданное в конструктор.
 */
/**
 * Основной API MetaFor для создания компонентов
 *
 * Предоставляет цепочку методов для настройки компонента:
 * - `context()` - определение типизированного контекста
 * - `states()` - определение состояний и переходов
 * - `core()` - настройка ядра для сложных данных
 * - `processes()` - определение процессов (действий)
 * - `reactions()` - определение реакций на события
 * - `view()` - определение представления компонента
 *
 * @example
 * ```typescript
 * const component = MetaFor("my-component")
 *   .context((types) => ({ name: types.string.required("") }))
 *   .states({ idle: { loading: {} } })
 *   .core({ users: [] })
 *   .processes((process) => ({ load: process().action(...) }))
 *   .reactions((reaction) => [...])
 *   .view({ render: ({ context }) => html`<div>${context.name}</div>` })
 * ```
 */
type MetaFor$1 = (name: string, config?: MetaForConfig) => {
	/**
	 * Регистрирует схему контекста для автомата.
	 *
	 * Контекст содержит только простые типы данных. Сложные объекты храните в core.
	 *
	 * @param schema Функция, принимающая types и возвращающая объект-схему контекста
	 * @returns chain API для вызова .states(...)
	 *
	 * @example
	 * ```typescript
	 * .context((types) => ({
	 *   userId: types.number.required(0),
	 *   userName: types.string.required("Anonymous"),
	 *   selectedIds: types.array.required([]),
	 *   isLoading: types.boolean.required(false),
	 *   theme: types.enum("light", "dark").required("dark"),
	 * }))
	 * ```
	 */
	context<C extends Schema>(schema: (types: Types) => C): {
		/**
		 * Регистрирует переходы автомата между состояниями.
		 *
		 * @param states Объект, где ключ — имя состояния, а значение — карта возможных переходов (ключ — следующее состояние, значение — условия или данные перехода).
		 * Пример:
		 * ```ts
		 * .states({
		 *   guest: { user: { name: "Пользователь" } },
		 *   user: { guest: {} },
		 * })
		 * ```
		 * @returns chain API для вызова .core(...)
		 */
		states<S extends string>(states: StatesConfig<S, C>): {
			/**
			 * Регистрирует core объект для автомата.
			 *
			 * Core - это простой объект с данными, используемыми во всех состояниях.
			 * Сложные объекты и структуры данных храните в core.
			 * Core доступен во всех процессах и реакциях.
			 *
			 * @param coreBuilder - функция, возвращающая core объект, или сам core объект
			 * @returns chain API для вызова .processes(...)
			 *
			 * @example
			 * ```typescript
			 * // Вариант 1: Функция
			 * .core(() => ({
			 *   users: [],
			 * }))
			 *
			 * // Вариант 2: Простой объект
			 * .core({
			 *   users: [],
			 *   settings: { theme: 'dark' },
			 *   cache: new Map()
			 * })
			 * ```
			 */
			core<I extends Core>(core?: I): {
				/**
				 * Регистрирует процессы автомата для нужных состояний.
				 *
				 * @param process Функция, принимающая process — фабрику chain API для описания процессов.
				 * Возвращает объект, где ключ — имя состояния (только для тех, где нужны процессы), а значение — chain-объект с обработчиками.
				 *
				 * Пример:
				 * ```ts
				 * .processes(process => ({
				 *   guest: process({ label: "guest_process", desc: "Процесс для гостя" })
				 *     .action(({ context }) => { ... })
				 *     .success(({ update, data }) => update({ ... }))
				 *     .error(({ update, error }) => update({ ... })),
				 *   // для других состояний можно не указывать процесс, если он не требуется
				 * }))
				 * ```
				 *
				 * @returns Объект с процессами только для нужных состояний
				 */
				processes(process?: ProcessesDeclaration<C, S, I>): {
					/**
					 * Регистрирует карту реакций для автомата.
					 *
					 * **ВАЖНО: Реакции предназначены для реагирования на события других акторов, а не на собственные изменения состояния.**
					 * Для управления собственными переходами состояний используйте процессы и их success/error обработчики.
					 * Реакции связывают разные акторы в событийной архитектуре.
					 *
					 * @param reaction Функция (filter => декларация), где декларация — массив кортежей [string[], { update, filter, label }]
					 * @returns chain API для вызова .view(...)
					 *
					 * @example
					 * ```typescript
					 * // Правильно: реакция на события другого актора
					 * .reactions(reaction => [
					 *   ["idle", "loading"], // Состояния, в которых активна реакция
					 *   {
					 *     filter: (args) => args.meta.tag === "roadmap" && args.patches[0]?.op === "replace",
					 *     update: ({ update, context, patch }) => {
					 *       update({
					 *         lastMessage: patch.value,
					 *         messageCount: context.messageCount + 1
					 *       })
					 *     },
					 *     label: "Обработка сообщений от roadmap актора"
					 *   }
					 * ])
					 *
					 * // Неправильно: реакция на собственные изменения
					 * // Вместо этого используйте процессы и их success/error обработчики
					 * ```
					 */
					reactions(reaction?: ReactionsDeclaration<C, S, I>): {
						/**
						 * Регистрирует представление компонента и завершает конфигурацию.
						 *
						 * @param view Конфигурация представления с render и style функциями
						 * @returns Компонент для создания элемента с тегом `meta-${name}`
						 *
						 * @example
						 * ```typescript
						 * const component = MetaFor("my-component")
						 *   .context(...)
						 *   .states(...)
						 *   .core(...)
						 *   .processes(...)
						 *   .reactions(...)
						 *   .view({
						 *     render: ({ context, html }) => html`<div>${context.label}</div>`,
						 *     style: ({ css }) => css`.container { color: blue; }`
						 *   })
						 *
						 * // Создание элемента с именем компонента
						 * document.body.innerHTML = `<meta-my-component></meta-my-component>`
						 * ```
						 */
						view(view?: ViewDeclaration<C, I, S>): Meta<C, S, I>;
					};
				};
			};
		};
	};
};
declare global {
	var DEV: boolean;
	interface Window {
		MetaFor: MetaFor$1;
	}
	var MetaFor: MetaFor$1;
}
/**
 * Конфигурация компонента MetaFor
 *
 * Опциональные параметры для настройки поведения компонента.
 *
 * @example
 * ```typescript
 * const config: MetaForConfig = {
 *   desc: "Компонент профиля пользователя",
 *   dev: true
 * }
 * ```
 */
export type MetaForConfig = {
	/** Описание компонента */
	desc?: string;
	/** Режим разработки */
	dev?: boolean;
};
/**
 * Параметры функции рендеринга представления актора.
 *
 * В функцию render компонента MetaFor передаётся объект с полезными утилитами и данными для построения UI.
 *
 * @example
 * ```ts
 * render({ context, update, state, html, ref, repeat, when, map, style }) {
 *   const inputRef = ref();
 *   return html`
 *     <div ${style({ color: state === 'error' ? 'red' : 'black' })}>
 *       <h2>${context.label}</h2>
 *       <input ${ref(inputRef)} value=${context.value} @input=${e => update({ value: e.target.value })} />
 *       <ul>
 *         ${repeat(context.items, (item, i) => html`<li>${i}: ${item}</li>`)}
 *       </ul>
 *       ${when(context.items.length > 0, () => html`<span>Есть элементы</span>`, () => html`<span>Пусто</span>`)}
 *       <ol>
 *         ${map(context.items, (item, i) => html`<li>${item}</li>`)}
 *       </ol>
 *     </div>
 *   `;
 * }
 * ```
 */
export type ViewDefinitionParams<C extends Schema = Schema, I extends Core = Core, S extends string = string> = {
	/**
	 * Функция для обновления контекста.
	 * Вызывается с частичным объектом контекста для изменения состояния.
	 * @example
	 * ```ts
	 * update({ value: 42 })
	 * ```
	 */
	update: Update<C>;
	/**
	 * Текущее состояние контекста.
	 * Содержит все поля, определённые в .context(...)
	 * @example
	 * ```ts
	 * html`<div>${context.value}</div>`
	 * ```
	 */
	context: Values<C>;
	core: I;
	/**
	 * Текущее состояние автомата/актора.
	 * Обычно строка, определённая в .states(...)
	 * @example
	 * ```ts
	 * html`<span>${state === 'error' ? 'Ошибка' : 'Ок'}</span>`
	 * ```
	 */
	state: S;
	/**
	 * Функция шаблонизации (аналог lit-html).
	 * Используется для создания HTML-шаблонов с интерполяцией.
	 * @example
	 * ```ts
	 * html`<div>${context.value}</div>`
	 * ```
	 */
	html: (strings: TemplateStringsArray, ...values: any[]) => void;
};
/**
 * Конфигурация для представления компонента.
 *
 * Поддерживает передачу контекста между компонентами через атрибут `context`.
 * При первой отрисовке контекст устанавливается без дополнительных сообщений,
 * при обновлении контекста родителя автоматически обновляется контекст ребенка.
 */
export interface ViewDeclaration<C extends Schema, I extends Core, S extends string> {
	/**
	 * Функция рендеринга компонента.
	 * Получает параметры с контекстом, состоянием и утилитами для построения UI.
	 *
	 * Поддерживает передачу контекста дочерним компонентам через атрибут `context`:
	 * ```ts
	 * render: ({ context, html }) => html`
	 *   <div>
	 *     <h1>Родитель: ${context.parentMessage}</h1>
	 *     <meta-child
	 *       context=${{
	 *         message: context.parentMessage,
	 *         count: context.parentCount,
	 *       }}></meta-child>
	 *   </div>
	 * `
	 * ```
	 */
	render?: (params: ViewDefinitionParams<C, I, S>) => void;
	/**
	 * Функция, вызываемая после монтирования компонента в DOM.
	 * Используется для инициализации после рендера.
	 */
	onMount?: ({ core }: {
		core: I;
	}) => void;
	/**
	 * Функция, вызываемая при уничтожении компонента.
	 * Используется для очистки ресурсов.
	 */
	onDestroy?: ({ core }: {
		core: I;
	}) => void;
	/**
	 * Функция для определения CSS-стилей компонента.
	 * Получает функцию css для создания инкапсулированных стилей.
	 */
	style?: ({ css }: {
		css: (strings: TemplateStringsArray, ...values: any[]) => void;
	}) => void;
}
/**
 * Схема компонента MetaFor
 *
 * Определяет полную структуру компонента включая контекст, состояния,
 * процессы, реакции и представление. Используется для создания акторов.
 *
 * @template C - Тип контекста (схема контекста)
 * @template S - Тип состояний (строковые литералы)
 * @template I - Тип ядра (объект для сложных данных)
 *
 * @example
 * ```typescript
 * const schema: Meta = {
 *   name: "user-profile",
 *   context: { name: types.string.required("") },
 *   states: { idle: { loading: {} } },
 *   core: { users: [] }
 * }
 * ```
 */
export interface Meta<C extends Schema = Schema, S extends string = string, I extends Core = {}> {
	/** Название компонента */
	name: string;
	/** Описание компонента */
	desc?: string;
	/** Карта состояний и переходов */
	states: StatesConfig<S, C>;
	/** Снимок процессов */
	processes?: ProcessesSchema;
	/** Снимок реакций */
	reactions?: ReactionsSchema;
	/** Схема контекста */
	context: C;
	/** Сериализованный view как ParseNode[] из @zavx0z/template */
	render?: NodeType[];
	/** Стили компонента */
	style?: string;
	/** Ядро */
	core: I;
}
/**
 * Базовая информация об акторе в системе MetaFor
 *
 * Содержит основную информацию о местоположении актора в иерархии.
 * Используется в фильтрах реакций, где не требуется доступ к методу destroy.
 *
 * @example
 * ```typescript
 * const selfInfo: SelfInfo = {
 *   meta: "user-profile",
 *   actor: "user-123",
 *   path: "0/1/2"
 * }
 * ```
 */
export type SelfInfo = {
	meta: string;
	actor: string;
	path: string;
};
/**
 * Полный идентификатор актора в системе MetaFor
 *
 * Наследует базовую информацию от SelfInfo и добавляет метод destroy.
 * Используется в процессах и обработчиках реакций (equal) для доступа к методу уничтожения актора.
 * В фильтрах реакций (filter) используется только SelfInfo без метода destroy.
 *
 * @example
 * ```typescript
 * const self: Self = {
 *   meta: "user-profile",
 *   actor: "user-123",
 *   path: "0/1/2",
 *   destroy: () => actor.destroy()
 * }
 * ```
 */
export type Self = SelfInfo & {
	destroy: () => void;
};

export {
	MetaFor$1 as MetaFor,
};

export {};
