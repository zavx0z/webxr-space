---
alwaysApply: true
---

# Правила MetaFor для AI агента

## Концепция фреймворка

MetaFor — это фреймворк для создания акторов на основе конечных автоматов. Каждый компонент является изолированным актором со своим состоянием, контекстом и логикой переходов.

### Позиционные пути (Path)

- Каждый актор имеет уникальный позиционный путь в VDOM (например, "0/1/2")
- Пути генерируются автоматически через `ActorHierarchy`
- Доступны в `Self` объекте: `{ meta, actor, path }`

### Расширенные фильтры реакций

- Доступ к контексту в функции `filter`: `filter(({ self, context }) => ...)`
- Декларативные условия фильтрации с поддержкой сложных условий
- Фильтрация по meta, actor, path, op, value, timestamp

### Иерархия акторов

- `ActorHierarchy` для управления позиционными путями
- Автоматическая генерация корневых путей
- Управление иерархией VDOM

## Архитектура компонента

### 1. Context — типизированное состояние

Контекст содержит **только примитивные типы данных**:

```typescript
.context((types) => ({
  // Строки
  name: types.string.required("Гость"),                    // обязательное поле
  email: types.string.optional(),                          // опциональное поле
  title: types.string.required("Заголовок")({ label: "Название" }), // с метаданными

  // Числа
  age: types.number.required(18),
  score: types.number.optional(),
  count: types.number.required(0)({ label: "Счетчик" }),

  // Булевы значения
  isActive: types.boolean.required(true),
  isVerified: types.boolean.optional(),

  // Перечисления (enum)
  role: types.enum("user", "admin", "moderator").required("user"),
  status: types.enum("draft", "published", "archived").optional(),

  // Массивы (только примитивов)
  tags: types.array.required(["default"]),
  categories: types.array.optional(),
  selectedIds: types.array.required([])({ label: "Выбранные ID" })
}))
```

**Правила:**

- Используй только примитивные типы: string, number, boolean, enum, array
- НЕ храни объекты в контексте
- Каждое поле может быть required или optional
- optional поля по умолчанию имеют значение null
- Метаданные добавляются через вызов функции: `({ label: "Описание" })`

### 2. Core — хранилище сложных данных

Core содержит сложные объекты, сервисы и DOM ссылки:

```typescript
.core((ref) => ({
  // Коллекции и объекты
  users: new Map<number, User>(),
  cache: new LRUCache(),
  settings: { theme: 'dark', lang: 'ru' },

  // Соединения и сервисы
  socket: null as WebSocket | null,
  apiService: new ApiService(),

  // Ссылки на DOM элементы
  formRef: ref(),        // создает ссылку на элемент
  inputRef: ref(),
  buttonRef: ref()
}))
```

**Правила:**

- Храни здесь любые сложные объекты
- ref() используется ТОЛЬКО для DOM элементов

### 3. States — конечный автомат

Состояния определяют узлы автомата и условия переходов:

```typescript
.states({
  // Начальное состояние
  idle: {
    loading: { userId: { gt: 0 } },        // переход при userId > 0
    error: {}                              // переход без условий
  },

  // Промежуточные состояния
  loading: {
    success: { data: { notEq: null } },    // переход при наличии данных
    error: { error: { notEq: "" } }        // переход при наличии ошибки
  },

  // Финальные состояния
  success: {
    idle: {},                              // возврат к началу
    editing: { mode: { eq: "edit" } }      // переход в режим редактирования
  },

  error: {
    idle: {},                              // возврат к началу
    retry: { retryCount: { lt: 3 } }       // повтор при retryCount < 3
  }
})
```

**Условия переходов:**

Для чисел:

- `eq: 5` — равно
- `gt: 10` — больше
- `gte: 0` — больше или равно
- `lt: 100` — меньше
- `lte: 50` — меньше или равно
- `between: [0, 100]` — диапазон

Для строк:

- `eq: "admin"` — равно
- `startsWith: "user_"` — начинается с
- `endsWith: ".pdf"` — заканчивается на
- `include: "test"` — содержит подстроку
- `pattern: /@gmail\.com$/` — регулярное выражение
- `length: { min: 2, max: 50 }` — длина строки

Для булевых значений:

- `eq: true` — равно
- `notEq: false` — не равно

Для массивов:

- `length: { gt: 0 }` — количество элементов
- `includes: "admin"` — содержит элемент
- `isEmpty: false` — не пустой

### 4. Processes — действия при входе в состояния

```typescript
.processes((process) => ({
  // Процесс для состояния "loading"
  loading: process({
    label: "Загрузка данных",
    description: "Загружает данные пользователя"
  })
    .action(async ({ context, core }) => {
      // Асинхронная логика
      const response = await fetch(`/api/users/${context.userId}`)
      const user = await response.json()
      return { user, timestamp: Date.now() }
    })
    .success(({ update, data, core }) => {
      // Синхронная обработка успеха
      core.users.set(data.user.id, data.user)
      update({
        userName: data.user.name,
        lastUpdate: data.timestamp,
        error: ""
      })
    })
    .error(({ update, error }) => {
      // Синхронная обработка ошибки
      update({
        error: error.message,
        retryCount: context.retryCount + 1
      })
    }),

  // Процесс для состояния "success"
  success: process()
    .action(() => {
      // Синхронное действие
      localStorage.setItem('lastSuccess', Date.now().toString())
      return { saved: true }
    })
    .success(({ update }) => {
      update({ status: "completed" })
    })
}))
```

**Правила:**

- Имя процесса = имя состояния
- action может быть async или sync
- success и error всегда синхронные
- Процесс выполняется при входе в состояние

### 5. Reactions — обработка сообщений от других компонентов

```typescript
// Сохрани имена компонентов для фильтрации
const childUserName = "child-user" // имя дочернего user компонента
const childFormName = "child-form" // имя дочернего form компонента

  .reactions((reaction) => [
    // Реакция активна в состояниях idle и loading
    [
      ["idle", "loading"], // НЕ используй ["*"]
      reaction({ label: "Обработка сообщений от user компонента" })
        .filter({
          meta: childUserName, // имя компонента-отправителя
          op: "replace", // операция: "add" | "replace" | "remove" | "test"
          path: "/context", // путь: "/" | "/context" | "/state"
          value: { userId: { gt: 0 } }, // условия на значение
        })
        .equal(({ update, patch, context, core, meta }) => {
          // Обработка сообщения
          const user = core.users.get(patch.value.userId)
          update({
            selectedUserName: user?.name || "Неизвестный",
            lastMessageTime: meta.timestamp,
          })
        }),
    ],

    // Реакция на добавление компонента
    [
      ["idle"],
      reaction({ label: "Компонент добавлен" })
        .filter({
          op: "add",
          path: "/",
        })
        .equal(({ patch }) => {
          console.log("Добавлен компонент:", patch.value)
        }),
    ],
  ])
```

**Фильтры реакций:**

- `meta` — имя компонента-отправителя
- `op` — операция: "add" | "replace" | "remove" | "test"
- `path` — путь изменения: "/" | "/context" | "/state"
- `value` — условия на значение (как в states)
- `timestamp` — временная метка

### 6. View — представление компонента

```typescript
.view({
  render: ({ context, state, core, html, update }) => {
    return html`
      <div class="component state-${state}">
        <!-- Отображение в зависимости от состояния -->
        ${state === "idle"
          ? html`
            <button onclick=${() => update({ userId: 123 })}>
              Загрузить пользователя
            </button>
          `
          : state === "loading"
            ? html`
              <div class="spinner">Загрузка...</div>
            `
            : state === "success"
              ? html`
                <form>
                  <input
                    value=${context.userName}
                    oninput=${(e) => update({ userName: e.target.value })}
                  />
                  <button type="submit">
                    Сохранить
                  </button>
                </form>
              `
              : html`
                <div class="error">${context.error}</div>
                <button onclick=${() => update({ retryCount: 0, userId: context.userId })}>
                  Повторить
                </button>
              `
        }

        <!-- Условный рендеринг -->
        ${context.isLoading && html`<div class="overlay">Обработка...</div>`}

        <!-- Циклы с map -->
        ${context.selectedIds.map(id => {
          const user = core.users.get(id)
          return html`<div>${user?.name || "Загрузка..."}</div>`
        })}
      </div>
    `
  },

  style: ({ css }) => css`
    .component {
      padding: 1rem;
    }

    .state-loading {
      opacity: 0.6;
    }

    .error {
      color: red;
    }
  `,

  onMount: ({ core }) => {
    // Инициализация после монтирования
    if (core.socket) {
      core.socket.addEventListener('message', core.handleMessage)
    }
  },

  onDestroy: ({ core }) => {
    // Очистка при уничтожении
    if (core.socket) {
      core.socket.close()
    }
  }
})
```

## Передача данных между компонентами

### Передача контекста и core дочерним компонентам

```typescript
// Сохрани имена дочерних компонентов
const userDetailsComponent = MetaFor("user-details")
  .context((types) => ({ userId: types.number.required(0) }))
  // ... остальная конфигурация
  .view(/* ... */)

const messengerComponent = MetaFor("messenger")
  .context((types) => ({ message: types.string.required("") }))
  // ... остальная конфигурация
  .view(/* ... */)

  // В родительском компоненте
  .view({
    render: ({ context, core, html }) => html`
      <div>
        <!-- Передача контекста -->
        <meta-details
          context=${{
            userId: context.selectedUserId,
          }}>
        </meta-details>

        <!-- Передача core объектов -->
        <meta-messenger
          core=${{
            socket: core.socket,
            apiService: core.apiService,
          }}>
        </meta-messenger>
      </div>
    `,
  })
```

## Создание компонента

```typescript
// Создание компонента
const userProfile = MetaFor("user-profile")
  .context((types) => ({
    userId: types.number.required(0),
    userName: types.string.required(""),
  }))
  .states({
    idle: { loading: { userId: { gt: 0 } } },
    loading: { success: {}, error: {} },
    success: { idle: {} },
    error: { idle: {} },
  })
  .core((ref) => ({
    users: new Map(),
    formRef: ref(),
  }))
  .processes((process) => ({
    loading: process()
      .action(async ({ context }) => {
        const response = await fetch(`/api/users/${context.userId}`)
        return await response.json()
      })
      .success(({ update, data }) => {
        update({ userName: data.name })
      })
      .error(({ update, error }) => {
        update({ error: error.message })
      }),
  }))
  .reactions((reaction) => [])
  .view({
    render: ({ context, html }) => html`<div>${context.userName}</div>`,
  })

document.body.innerHTML = `<meta-counter></meta-counter>`
```

## Важные правила

1. **Контекст** — только примитивы (string, number, boolean, enum, array)
