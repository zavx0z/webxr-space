---
description:
globs:
alwaysApply: true
---

# Правила производительности

Объекты и классы
• Стабилизируй shape (скрытые классы):
• Инициализируй все поля в constructor (или инициализаторах класса), даже null/undefined.
• Не добавляй/удаляй поля позже (delete избегать) — лучше присвоить null.
• Одинаковый порядок присваивания полей у всех инстансов.
• Методы — на прототипе:
class A { method() {} } → одна функция на всех.
Избегай method = () => {} в полях: это новая функция на каждый инстанс.
• Контекст this:
• Не делай bind на каждый вызов. Если нужно — один bind на инстанс или передавай thisArg отдельно: fn.call(thisArg, ...).
• Альтернатива без класса: Object.create(proto) — общий прототип, минимум аллокаций.
• Асинхронная инициализация:
• Конструктор не async. Используй static async create() или new A(); await a.init().

Функции и замыкания
• Избегай фабрик, которые создают замыкания на инстанс (держат лексическую среду).
Данные → в поля объекта, логика → в прототипные методы.
• Не создавай функции в горячих путях («внутри цикла/рендера»). Выноси наружу и переиспользуй.
• Кешируй «одноразовые» обёртки: #handler ??= (ev)=>....

Память и GC
• Структуры: для динамических ключей — Map/Set; для эпизодических данных на объект — WeakMap<Obj,Data>.
• Ссылки: не держи долгоживущие ссылки на DOM/инстансы без нужды; отписывай слушатели в cleanup.
• Массивы/строки: избегай частой конкатенации в цикле → используйте буферы/join.
• Большие объёмы: реюзай буферы/объекты (pooling), где оправдано.

DOM и рендер
• Минимизируй трогание DOM:
• Батчи обновления (микротаски, requestAnimationFrame), избегай чередования read/write (layout thrash).
• Изменяй атрибут/текст только если значение реально поменялось.
• Создание — во DocumentFragment, потом один вставочный патч.
• Поиск элементов: хранить ссылки (Map/ID-реестр) вместо частых querySelector\* на большом числе узлов.
• События: делегирование на контейнер вместо тысячи обработчиков.
• Стили: CSSStyleSheet/adoptedStyleSheets (reuse одного шита), минимум inline-стиля.

Асинхронщина и конкуренция
• AbortController для отмены задач; проверяй signal.aborted в долгих операциях.
• Web Worker / BroadcastChannel:
• Не плодить каналы по одному на актор; группируй по домену/типу.
• Передавай идентификаторы, не большие объекты (сериализация дорога).
• Строго определяй протокол сообщений (тип, версия, payload).
• Дебаунс/троттлинг на частых событиях (scroll, resize, input).

Данные и алгоритмы
• Выбирай правильные структуры: Set для принадлежности, Map для словаря, массив для плотных коллекций.
• Частые операции O(1|logN) предпочтительнее «удобных», но O(N).
• Кеширование результатов (memoize) для детерминированных чистых функций; инвалидируй явно.

Модули и сборка (даже если без бандлера)
• Импорты почти бесплатны в рантайме; узкое место — доставка/парсинг. Делай ленивую загрузку холодных путей (import()).
• Не плодить реэкспортные «цепочки» — мешают tree-shaking (если подключишь сборщик позже).
• «Горячие» методы — внутри класса; «холодные» утилиты — можно вынести.

Исключения и ошибки
• Исключения дороги при частоте. Не используйте try/catch в горячем цикле; обрамляй ближе к границам.
• Логи — асинхронно/агрегированно, не спамить консоль в горячем пути.

Микрооптимизации (когда уже всё остальное сделано)
• Предвари Object.keys(...) / RegExp вне циклов.
• Предпочитай числовые счета без лишних преобразований типов.
• Используй моноформные поля (один и тот же тип значения для одного поля у всех инстансов).

Профилирование (делай замеры, а не угадывай)
• Chrome DevTools: Performance (CPU/флейм), Memory (Allocation/Heap Snapshot), Lighthouse для базовой оценки.
• Метрики: время кадра (16.7ms целевой), число DOM-узлов, частота GC, издержки сериализации, размер сообщений.
• Пиши микро-бенчмарки на реальных данных (Node/Bun bench, performance.now()).

⸻

Короткий чеклист (для «горячих» сущностей)
• Все поля объявлены/инициализированы в конструкторе (стабильный shape).
• Методы — в prototype. Никаких () => {} в полях, кроме редких единичных случаев.
• Нет bind/стрелок «на каждый вызов». Если надо — один раз на инстанс или передача thisArg.
• Батчинг DOM-изменений, никаких лишних setAttribute при прежнем значении.
• Нет лишних querySelector\* в цикле — есть реестр ссылок.
• Закрываешь ресурсы: отписка, abort, таймеры, обнуление ссылок.
• Сообщения между потоками — компактные, по протоколу, без больших копий.
• Замерено профайлером, а не «кажется быстрее».
